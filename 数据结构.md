[toc]

### 数据结构 

#### 一 数据机构概述

##### 1.1 什么是数据结构

时隔多日从新学习什么是数据结构。本节，我们先来讲什么是数据结构。

![什么是数据结构](http://data.biancheng.net/uploads/allimg/181118/1-1Q11Q31302a3.gif)

 

数据结构，直白地理解，就是**研究数据的存储方式**。

我们知道，**数据存储只有一个目的，即为了方便后期对数据的再利用**，就如同我们使用[数组](http://data.biancheng.net/view/181.html)

存储 `{1,2,3,4,5}` 是为了后期取得它们的加和值，无缘由的数据存储行为是对存储空间的不负责任。

因此，数据在计算机存储空间的存放，决不是胡乱的，这就要求我们选择一种好的方式来存储数据，而这也是数据结构的核心内容。

例如，一直以来大家面对的数据存储，都是类似存储 1、2、{a,b,c} 这样的问题，解决方式无疑是用变量或者数组对数据进行存储，即：

```c
int a=1;
int b=2;
char str[3]={'a','b','c'};
```

但是，如果要存储这样一组数据：{张亮，张平，张华，张群，张晶，张磊}，数据之间具有这样的关系：张亮是张平、张华和张群的父亲，同时张平还是张晶和张磊的父亲，数据之间的关系如 图1 所示：


![img](http://data.biancheng.net/uploads/allimg/171121/2-1G12114514Y03.png)

​								

<center>图 1 数据及数据之间的关系</center>


对于存储之间具有复杂关系的数据，如果还是用变量或数组来存储（比如用数组存储 {“张亮”,"张平",“张华”,"张群","张晶","张磊"} ），数据存储是没有问题，但是无法体现数据之间的逻辑关系，后期根本无法使用，显然不明智。

> 针对此类数据，数据结构中提供有专门的[树](http://data.biancheng.net/view/23.html)结构来存储这类数据。

再比如，导航无疑是出游旅行的必备神器，在我们程序员眼中，无论是哪款导航软件，其导航功能的实现都需要大量地图数据的支持。很明显，这些数据绝不是使用变量或数组进行存储的，那样对于数据的使用简直是个悲剧。

> 针对此类数据，数据结构提供了图存储结构，专门用于存储这类数据。

通过以上两个示例可以体会出，数据结构教会我们的绝不仅仅是如何存储 1、2、{a,b,c} 这样简单的数据，而是解决具有复杂关系的大量数据的存储问题。

因此，数据结构是什么? **我认为，数据结构是一门学科，它教会我们“如何存储具有复杂关系的数据更有助于后期对数据的再利用”。**

**本节概括** 

①数据结构，直白地理解，就是研究数据的存储方式

②数据存储只有一个目的，即为了方便后期对数据的再利用

③数据结构是一门学科，它教会我们“如何存储具有复杂关系的数据更有助于后期对数据的再利用

##### 1.2 数据结构到底学什么

 通过上节我们知道，数据结构是学习数据存储方式的一门学科，那么，数据存储方式有哪几种呢？本节将对数据结构的学习内容做一个简要的总结。

数据结构大致包含以下几种存储结构：

- [线性表](http://data.biancheng.net/view/157.html)，还可细分为[顺序表](http://data.biancheng.net/view/158.html)、[链表](http://data.biancheng.net/view/160.html)、[栈](http://data.biancheng.net/view/169.html)和[队列](http://data.biancheng.net/view/172.html)；
- [树](http://data.biancheng.net/view/23.html)结构，包括普通树，[二叉树](http://data.biancheng.net/view/192.html)，线索二叉树等；
- [图](http://data.biancheng.net/view/200.html)存储结构；


下面对各种数据结构做详细讲解。

**线性表**

线性表结构存储的数据往往是可以依次排列的，就像小朋友手拉手，每位学生的前面和后面都仅有一个小朋友和他拉手，具备这种“一对一”关系的数据就可以使用线性表来存储。

![手拉手的小朋友](http://data.biancheng.net/uploads/allimg/181118/1-1Q11QH151411.gif)


例如，存储类似 {1,3,5,7,9} 这样的数据时，各元素依次排列，每个元素的前面和后边有且仅有一个元素与之相邻（除首元素和尾元素），因此可以使用线性表存储。

线性表并不是一种具体的存储结构，它包含顺序存储结构和链式存储结构，是顺序表和链表的统称。

**顺序表**

顺序表，简单地理解，就是常用的[数组](http://data.biancheng.net/view/181.html)，只是换了个名字而已，例如使用顺序表存储 {1,3,5,7,9}，如图 1 所示：

![顺序表结构](http://data.biancheng.net/uploads/allimg/181118/1-1Q11QI9559D.gif)

<center>图 1 顺序表结构</center>

由于顺序表结构的底层实现借助的就是数组，因此对于初学者来说，可以把顺序表完全等价为数组**，但实则不是这样。数据结构是研究数据存储方式的一门学科，它囊括的都是各种存储结构，而数组只是各种编程语言中的基本数据类型**，并不属于数据结构的范畴。

**链表**

我们知道，使用顺序表（底层实现靠数组）时，需要提前申请一定大小的存储空间，这块存储空间的物理地址是连续的，如图 1 所示。

链表则完全不同，使用链表存储数据时，是随用随申请，因此数据的存储位置是相互分离的，换句话说，数据的存储位置是随机的。

为了给各个数据块建立“依次排列”的关系，链表给各数据块增设一个指针，每个数据块的指针都指向下一个数据块（最后一个数据块的指针指向 NULL），就如同一个个小学生都伸手去拉住下一个小学生的手，这样，看似毫无关系的数据块就建立了“依次排列”的关系，也就形成了链表，如图 2 所示：

​                 

![链表结构](http://data.biancheng.net/uploads/allimg/181118/1-1Q11QH334H1.gif)

<center>图 2 链表结构</center>

**栈和队列**

栈和队列隶属于线性表，是特殊的线性表，因为它们对线性表中元素的进出做了明确的要求。

栈中的元素只能从线性表的一端进出（另一端封死），且要遵循“先入后出”的原则，即先进栈的元素后出栈。



![栈结构示意图](http://data.biancheng.net/uploads/allimg/181118/1-1Q11QH634D9.gif)

<center>图 3 栈结构示意图</center>


栈结构如图 3 所示，像一个木桶，栈中含有 3 个元素，分别是 A、B 和 C，从在栈中的状态可以看出 A 最先进的栈，然后 B 进栈，最后 C 进栈。根据“先进后出”的原则，3 个元素出栈的顺序应该是：C 最先出栈，然后 B 出栈，最后才是 A 出栈。

队列中的元素只能从线性表的一端进，从另一端出，且要遵循“先入先出”的特点，即先进队列的元素也要先出队列。


![队列结构示意图](http://data.biancheng.net/uploads/allimg/181118/1-1Q11QHIJO.gif)

<center>图 4 队列结构示意图</center>

队列结构如图 4 所示，队列中有 3 个元素，分别是 A、B 和 C，从在队列中的状态可以看出是 A 先进队列，然后 B 进，最后 C 进。根据“先进先出”的原则，3 个元素出队列的顺序应该是 A 最先出队列，然后 B 出，最后 C 出。

**树存储结构**

树存储结构**适合存储具有“一对多**”关系的数据。

​                           																![家庭族谱](http://data.biancheng.net/uploads/allimg/181118/1-1Q11QJJ0142.gif)     

<center>图 5 家庭族谱</center>


如图 5 所示，其中张平只有一个父亲，但他却有两（多）个孩子，这就是“一对多”的关系，满足这种关系的数据可以使用树存储结构。

**图存储结构**

图存储结构适合存储**具有“多对多”关系**的数据。


![图存储结构示意图](http://data.biancheng.net/uploads/allimg/181118/1-1Q11QIFS44.gif)

<center>图 6 图存储结构示意图</center>

如图 6 所示，从 V1 可以到达 V2、V3、V4，同样，从 V2、V3、V4 也可以到达 V1，这就是“多对多”的关系，满足这种关系的数据可以使用图存储结构。

> 本节只是对数据结构中包含的各种存储结构做一个简要的介绍，各存储结构具体的实现会在后续文章中作详解介绍。



#### 二 线性表 

##### 1.1 什么是线性表 

线性表，全名为线性存储结构。使用线性表存储数据的方式可以这样理解，即“把所有数据用一根线儿[串](http://data.biancheng.net/view/175.html)起来，再存储到物理空间中”。

!["一对一"逻辑关系的数据](http://data.biancheng.net/uploads/allimg/181120/1-1Q120214QJ63.gif)

<center>图1 "一对一"逻辑关系的数据</center>


如图 1 所示，这是一组具有“一对一”关系的数据，我们接下来采用线性表将其储存到物理空间中。

首先，用“一根线儿”把它们按照顺序“串”起来，如图 2 所示：


![img](http://data.biancheng.net/uploads/allimg/181120/1-1Q12021551W22.gif)

<center>图 2 数据的"线性"结构</center>


图 2 中，左侧是“串”起来的数据，右侧是空闲的物理空间。把这“一串儿”数据放置到物理空间，我们可以选择以下两种方式，如图 3 所示。


![两种线性存储结构](http://data.biancheng.net/uploads/allimg/181120/1-1Q120215009361.gif)

<center>图 3 两种线性存储结构



图 3a) 是多数人想到的存储方式，而图 3b) 却少有人想到。我们知道，**数据存储的成功与否，取决于是否能将数据完整地复原成它本来的样子**。如果把图 3a) 和图 3b) 线的一头扯起，你会发现数据的位置依旧没有发生改变（和图 1 一样)。因此可以认定，这两种存储方式都是正确的。

将具有“一对一”关系的数据“线性”地存储到物理空间中，这种存储结构就称为线性存储结构（简称线性表）。

**使用线性表存储的数据，如同向[数组](http://data.biancheng.net/view/181.html)中存储数据那样，要求数据类型必须一致**

> 也就是说，线性表存储的数据，要么全不都是整形，要么全部都是字符串。一半是整形，另一半是字符串的一组数据无法使用线性表存储。



**一 顺序存储结构和链式存储结构**

图 3 中我们可以看出，线性表存储数据可细分为以下 2 种：

1. 如图 3a) 所示，将数据依次存储在连续的整块物理空间中，这种存储结构称为顺序存储结构（简称[顺序表](http://data.biancheng.net/view/158.html)）；
2. 如图 3b) 所示，数据分散的存储在物理空间中，通过一根线保存着它们之间的逻辑关系，这种存储结构称为链式存储结构（简称[链表](http://data.biancheng.net/view/160.html)）；


也就是说，线性表存储结构可细分为顺序存储结构和链式存储结构。

**二 线性表常用术语**

数据结构中，一组数据中的每个个体被称为“数据元素”（简称“元素”）。例如，图 1 显示的这组数据，其中 1、2、3、4 和 5 都是这组数据钟的一个元素。

另外，对于具有“一对一”逻辑关系的数据，我们一直在用“某一元素的左侧（前边）或右侧（后边）”这样不专业的词，其实线性表中有更准确的术语：

- 某一元素的左侧相邻元素称为“直接前驱”，位于此元素左侧的所有元素都统称为“前驱元素”；
- 某一元素的右侧相邻元素称为“直接后继”，位于此元素右侧的所有元素都统称为“后继元素”；


以图 1 数据中的元素 3 来说，它的直接前驱是 2 ，此元素的前驱元素有 2 个，分别是 1 和 2；同理，此元素的直接后继是 4 ，后继元素也有 2 个，分别是 4 和 5。如图 4 所示：


![前驱和后继](http://data.biancheng.net/uploads/allimg/181120/1-1Q1202152464R.gif)

<center>图 4 前驱和后继</center>

##### 2.2 顺序表是什么 

顺序表，全名顺序存储结构，是[线性表](http://data.biancheng.net/view/157.html)的一种。通过《[线性表](http://data.biancheng.net/view/157.html)》一节的学习我们知道，线性表用于存储逻辑关系为“一对一”的数据，顺序表自然也不例外。

不仅如此，顺序表对数据的物理存储结构也有要求。顺序表存储数据时，会提前申请一整块足够大小的物理空间，然后将数据依次存储起来，存储时做到数据元素之间不留一丝缝隙。

例如，使用顺序表存储集合 `{1,2,3,4,5}`，数据最终的存储状态如图1 所示：


![img](http://data.biancheng.net/uploads/allimg/181121/2-1Q121202555F0.gif)

<center>图 1 顺序存储结构示意图


由此我们可以得出，将“具有 '一对一' 逻辑关系的数据按照次序连续存储到一整块物理空间上”的存储结构就是顺序存储结构。

通过观察图 1 中数据的存储状态，我们可以发现，顺序表存储数据同[数组](http://data.biancheng.net/view/181.html)非常接近。其实，顺序表存储数据使用的就是数组。

>顺序表实现使用的是数组，但是两者性质不同，前者针对的是数据的存储，而后者是基本的数据类型

**一 顺序表的初始化**

使用顺序表存储数据之前，除了要申请足够大小的物理空间之外，为了方便后期使用表中的数据，顺序表还需要实时记录以下 2 项数据：

1. 顺序表申请的存储容量；
2. 顺序表的长度，也就是表中存储数据元素的个数；

提示：正常状态下，顺序表申请的存储容量要大于顺序表的长度。

因此，我们需要自定义顺序表，C 语言实现代码如下：

```c
typedef struct Table{    
    int * head;//声明了一个名为head的长度不确定的数组，也叫“动态数组”    
    int length;//记录当前顺序表的长度    
    int size;//记录顺序表分配的存储容量
}table;
```

注意，head 是我们声明的一个未初始化的动态数组，不要只把它看做是普通的指针。

接下来开始学习顺序表的初始化，也就是初步建立一个顺序表。建立顺序表需要做如下工作：

- 给 head 动态数据申请足够大小的物理空间；
- 给 size 和 length 赋初值；


因此，C 语言实现代码如下：

```c
#define Size 5 //对Size进行宏定义，表示顺序表申请空间的大小
table initTable(){    
    table t;   
    t.head = (int*)malloc(Size * sizeof(int));//构造一个空的顺序表，动态申请存储空间   
    if (!t.head) //如果申请失败，作出提示并直接退出程序   
    {        printf("初始化失败");     
     exit(0);    }   
    t.length = 0;//空表的长度初始化为0   
    t.size = Size;//空表的初始存储空间为Size   
    return t;}
```

我们看到，整个顺序表初始化的过程被封装到了一个函数中，此函数返回值是一个已经初始化完成的顺序表。这样做的好处是增加了代码的可用性，也更加美观。与此同时，顺序表初始化过程中，要注意对物理空间的申请进行判断，对申请失败的情况进行处理，这里只进行了“输出提示信息和强制退出”的操作，可以根据你自己的需要对代码中的 if 语句进行改进。

通过在主函数中调用 initTable 语句，就可以成功创建一个空的顺序表，与此同时我们还可以试着向顺序表中添加一些元素，C 语言实现代码如下：

```c
#include <stdio.h>
#include <stdlib.h>  //malloc()、exit()
#define Size 5
typedef struct Table {
    int * head;
    int length;
    int size;
}table;
table initTable() {
    table t;
    t.head = (int*)malloc(Size * sizeof(int));
    if (!t.head)
    {
        printf("初始化失败");
        exit(0);
    }
    t.length = 0;
    t.size = Size;
    return t;
}
//输出顺序表中元素的函数
void displayTable(table t) {
    int i;
    for (i = 0; i < t.length; i++) {
        printf("%d ", t.head[i]);
    }
    printf("\n");
}
int main() {
    int i;
    table t = initTable();
    //向顺序表中添加元素
    for (i = 1; i <= Size; i++) {
        t.head[i - 1] = i;
        t.length++;
    }
    printf("顺序表中存储的元素分别是：\n");
    displayTable(t);
    return 0;
}-
```

程序运行结果如下：

```shell
顺序表中存储的元素分别是：
1 2 3 4 5
```

可以看到，顺序表初始化成功。



##### 2.3 顺序表的基本操作 

我们学习了[顺序表](http://data.biancheng.net/view/158.html)及初始化的过程，本节学习有关顺序表的一些基本操作，以及如何使用 C 语言实现它们。

###### 2.3.1 顺序表插入元素

向已有顺序表中插入数据元素，根据插入位置的不同，可分为以下 3 种情况：

1. 插入到顺序表的表头；
2. 在表的中间位置插入元素；
3. 尾随顺序表中已有元素，作为顺序表中的最后一个元素；


虽然数据元素插入顺序表中的位置有所不同，但是都使用的是同一种方式去解决，即：通过遍历，找到数据元素要插入的位置，然后做如下两步工作：

- 将要插入位置元素以及后续的元素整体向后移动一个位置；
- 将元素放到腾出来的位置上；


例如，在 `{1,2,3,4,5}` 的第 3 个位置上插入元素 6，实现过程如下：

- 遍历至顺序表存储第 3 个数据元素的位置，如[图](http://data.biancheng.net/view/200.html) 1 所示：


![找到目标元素位置](http://data.biancheng.net/uploads/allimg/181122/2-1Q122201300X8.gif)

<center>图 1 找到目标元素位置</center>

- 将元素 3 以及后续元素 4 和 5 整体向后移动一个位置，如图 2 所示：


![将插入位置腾出](http://data.biancheng.net/uploads/allimg/181122/2-1Q122201355232.gif)

<center>图 2 将插入位置腾出</center>

- 将新元素 6 放入腾出的位置，如图 3 所示：


![插入目标元素](http://data.biancheng.net/uploads/allimg/181122/2-1Q12220142H50.gif)

<center>图 3 插入目标元素</center>


因此，顺序表插入数据元素的 C 语言实现代码如下：

```c
//插入函数，其中，elem为插入的元素，add为插入到顺序表的位置
table addTable(table t, int elem, int add)
{
    int i;
    //判断插入本身是否存在问题（如果插入元素位置比整张表的长度+1还大（如果相等，是尾随的情况），或者插入的位置本身不存在，程序作为提示并自动退出）
    if (add > t.length + 1 || add < 1) {
        printf("插入位置有问题");
        return t;
    }
    //做插入操作时，首先需要看顺序表是否有多余的存储空间提供给插入的元素，如果没有，需要申请
    if (t.length == t.size) {
        t.head = (int *)realloc(t.head, (t.size + 1) * sizeof(int));
        if (!t.head) {
            printf("存储分配失败");
            return t;
        }
        t.size += 1;
    }
    //插入操作，需要将从插入位置开始的后续元素，逐个后移
    for (i = t.length - 1; i >= add - 1; i--) {
        t.head[i + 1] = t.head[i];
    }
    //后移完成后，直接将所需插入元素，添加到顺序表的相应位置
    t.head[add - 1] = elem;
    //由于添加了元素，所以长度+1
    t.length++;
    return t;
}
```

注意，动态[数组](http://data.biancheng.net/view/181.html)额外申请更多物理空间使用的是 realloc 函数。并且，在实现后续元素整体后移的过程，目标位置其实是有数据的，还是 3，只是下一步新插入元素时会把旧元素直接覆盖。

**二 顺序表删除元素**

从顺序表中删除指定元素，实现起来非常简单，只需找到目标元素，并将其后续所有元素整体前移 1 个位置即可。

后续元素整体前移一个位置，会直接将目标元素删除，可间接实现删除元素的目的。

例如，从 `{1,2,3,4,5}` 中删除元素 3 的过程如图 4 所示：


![img](http://data.biancheng.net/uploads/allimg/181122/2-1Q122201629521.gif)

<center>图 4 顺序表删除元素的过程示意图</center>


因此，顺序表删除元素的 C 语言实现代码为：

```c
table delTable(table t, int add) {
    int i;
    if (add > t.length || add < 1) {
        printf("被删除元素的位置有误");
        exit(0);
    }
    //删除操作
    for (i = add; i < t.length; i++) {
        t.head[i - 1] = t.head[i];
    }
    t.length--;
    return t;
}
```

**三 顺序表查找元素**

顺序表中查找目标元素，可以使用多种查找算法实现，比如说[二分查找](http://data.biancheng.net/view/55.html)算法、插值查找算法等。

这里，我们选择[顺序查找](http://data.biancheng.net/view/54.html)算法，具体实现代码为：

```c
//查找函数，其中，elem表示要查找的数据元素的值
int selectTable(table t, int elem) {
    int i;
    for (i = 0; i < t.length; i++) {
        if (t.head[i] == elem) {
            return i + 1;
        }
    }
    return -1;//如果查找失败，返回-1
}
```

**四 顺序表更改元素**

顺序表更改元素的实现过程是：

1. 找到目标元素；
2. 直接修改该元素的值；


顺序表更改元素的 C 语言实现代码为：

~~~c
//更改函数，其中，elem为要更改的元素，newElem为新的数据元素
table amendTable(table t, int elem, int newElem) {
    int add = selectTable(t, elem);
    t.head[add - 1] = newElem;//由于返回的是元素在顺序表中的位置，所以-1就是该元素在数组中的下标
    return t;
}
~~~

以上是顺序表使用过程中最常用的基本操作，这里给出本节完整的实现代码：

~~~c
#include <stdio.h>
#include <stdlib.h>
#define Size 5
typedef struct Table {
    int * head;
    int length;
    int size;
}table;
table initTable() {
    table t;
    t.head = (int*)malloc(Size * sizeof(int));
    if (!t.head)
    {
        printf("初始化失败");
        exit(0);
    }
    t.length = 0;
    t.size = Size;
    return t;
}
table addTable(table t, int elem, int add)
{
    int i;
    if (add > t.length + 1 || add < 1) {
        printf("插入位置有问题");
        return t;
    }
    if (t.length >= t.size) {
        t.head = (int *)realloc(t.head, (t.size + 1) * sizeof(int));
        if (!t.head) {
            printf("存储分配失败");
        }
        t.size += 1;
    }
    for (i = t.length - 1; i >= add - 1; i--) {
        t.head[i + 1] = t.head[i];
    }
    t.head[add - 1] = elem;
    t.length++;
    return t;
}
table delTable(table t, int add) {
    int i;
    if (add > t.length || add < 1) {
        printf("被删除元素的位置有误");
        exit(0);
    }
    for (i = add; i < t.length; i++) {
        t.head[i - 1] = t.head[i];
    }
    t.length--;
    return t;
}
int selectTable(table t, int elem) {
    int i;
    for (i = 0; i < t.length; i++) {
        if (t.head[i] == elem) {
            return i + 1;
        }
    }
    return -1;
}
table amendTable(table t, int elem, int newElem) {
    int add = selectTable(t, elem);
    t.head[add - 1] = newElem;
    return t;
}
void displayTable(table t) {
    int i;
    for (i = 0; i < t.length; i++) {
        printf("%d ", t.head[i]);
    }
    printf("\n");
}
int main() {
    int i, add;
    table t1 = initTable();
    for (i = 1; i <= Size; i++) {
        t1.head[i - 1] = i;
        t1.length++;
    }
    printf("原顺序表：\n");
    displayTable(t1);

    printf("删除元素1:\n");
    t1 = delTable(t1, 1);
    displayTable(t1);

    printf("在第2的位置插入元素5:\n");
    t1 = addTable(t1, 5, 2);
    displayTable(t1);

    printf("查找元素3的位置:\n");
    add = selectTable(t1, 3);
    printf("%d\n", add);

    printf("将元素3改为6:\n");
    t1 = amendTable(t1, 3, 6);
    displayTable(t1);
    return 0;
}
~~~

程序运行结果为：

~~~shell
原顺序表：
1 2 3 4 5
删除元素1:
2 3 4 5
在第2的位置插入元素5:
2 5 3 4 5
查找元素3的位置:
3
将元素3改为6:
2 5 6 4 5
~~~





