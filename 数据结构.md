[toc]



#### 一 数据结构概述

>https://cwsong.lanzoui.com/b0cwh04lc 

##### 1.1 什么是数据结构

时隔多日从新学习数据结构。

这次 侧重代码一点 

偷偷学习数据结构，惊艳所有人！

![什么是数据结构](http://data.biancheng.net/uploads/allimg/181118/1-1Q11Q31302a3.gif)

 

数据结构，直白地理解，就是**研究数据的存储方式**。

我们知道，**数据存储只有一个目的，即为了方便后期对数据的再利用**，就如同我们使用数组

存储 `{1,2,3,4,5}` 是为了后期取得它们的加和值，无缘由的数据存储行为是对存储空间的不负责任。

因此，数据在计算机存储空间的存放，决不是胡乱的，这就要求我们选择一种好的方式来存储数据，而这也是数据结构的核心内容。

例如，一直以来大家面对的数据存储，都是类似存储 1、2、{a,b,c} 这样的问题，解决方式无疑是用变量或者数组对数据进行存储，即：

```c
int a=1;
int b=2;
char str[3]={'a','b','c'};
```

但是，如果要存储这样一组数据：{张亮，张平，张华，张群，张晶，张磊}，数据之间具有这样的关系：张亮是张平、张华和张群的父亲，同时张平还是张晶和张磊的父亲，数据之间的关系如 图1 所示：


![img](http://data.biancheng.net/uploads/allimg/171121/2-1G12114514Y03.png)

​								

<center>图 1 数据及数据之间的关系</center>


对于存储之间具有复杂关系的数据，如果还是用变量或数组来存储（比如用数组存储 {“张亮”,"张平",“张华”,"张群","张晶","张磊"} ），数据存储是没有问题，但是无法体现数据之间的逻辑关系，后期根本无法使用，显然不明智。

> 针对此类数据，数据结构中提供有专门的[树](http://data.biancheng.net/view/23.html)结构来存储这类数据。

再比如，导航无疑是出游旅行的必备神器，在我们程序员眼中，无论是哪款导航软件，其导航功能的实现都需要大量地图数据的支持。很明显，这些数据绝不是使用变量或数组进行存储的，那样对于数据的使用简直是个悲剧。

> 针对此类数据，数据结构提供了图存储结构，专门用于存储这类数据。

通过以上两个示例可以体会出，数据结构教会我们的绝不仅仅是如何存储 1、2、{a,b,c} 这样简单的数据，而是解决具有复杂关系的大量数据的存储问题。

因此，数据结构是什么? **我认为，数据结构是一门学科，它教会我们“如何存储具有复杂关系的数据更有助于后期对数据的再利用”。**

**本节概括** 

①数据结构，直白地理解，就是研究数据的存储方式

②数据存储只有一个目的，即为了方便后期对数据的再利用

③数据结构是一门学科，它教会我们“如何存储具有复杂关系的数据更有助于后期对数据的再利用

##### 1.2 数据结构到底学什么

 通过上节我们知道，数据结构是学习数据存储方式的一门学科，那么，数据存储方式有哪几种呢？本节将对数据结构的学习内容做一个简要的总结。

数据结构大致包含以下几种存储结构：

- 线性表，还可细分为顺序表、链表、栈和队列；
- [树](http://data.biancheng.net/view/23.html)结构，包括普通树，[二叉树](http://data.biancheng.net/view/192.html)，线索二叉树等；
- 图存储结构；


下面对各种数据结构做详细讲解。

**线性表**

线性表结构存储的数据往往是可以依次排列的，就像小朋友手拉手，每位学生的前面和后面都仅有一个小朋友和他拉手，具备这种“一对一”关系的数据就可以使用线性表来存储。

![手拉手的小朋友](http://data.biancheng.net/uploads/allimg/181118/1-1Q11QH151411.gif)


例如，存储类似 {1,3,5,7,9} 这样的数据时，各元素依次排列，每个元素的前面和后边有且仅有一个元素与之相邻（除首元素和尾元素），因此可以使用线性表存储。

线性表并不是一种具体的存储结构，它包含顺序存储结构和链式存储结构，是顺序表和链表的统称。

**顺序表**

顺序表，简单地理解，就是常用的数组，只是换了个名字而已，例如使用顺序表存储 {1,3,5,7,9}，如图 1 所示：

![顺序表结构](http://data.biancheng.net/uploads/allimg/181118/1-1Q11QI9559D.gif)

<center>图 1 顺序表结构</center>

由于顺序表结构的底层实现借助的就是数组，因此对于初学者来说，可以把顺序表完全等价为数组**，但实则不是这样。数据结构是研究数据存储方式的一门学科，它囊括的都是各种存储结构，而数组只是各种编程语言中的基本数据类型**，并不属于数据结构的范畴。

**链表**

我们知道，使用顺序表（底层实现靠数组）时，需要提前申请一定大小的存储空间，这块存储空间的物理地址是连续的，如图 1 所示。

链表则完全不同，使用链表存储数据时，是随用随申请，因此数据的存储位置是相互分离的，换句话说，数据的存储位置是随机的。

为了给各个数据块建立“依次排列”的关系，链表给各数据块增设一个指针，每个数据块的指针都指向下一个数据块（最后一个数据块的指针指向 NULL），就如同一个个小学生都伸手去拉住下一个小学生的手，这样，看似毫无关系的数据块就建立了“依次排列”的关系，也就形成了链表，如图 2 所示：

​                 

![链表结构](http://data.biancheng.net/uploads/allimg/181118/1-1Q11QH334H1.gif)

<center>图 2 链表结构</center>

**栈和队列**

栈和队列隶属于线性表，是特殊的线性表，因为它们对线性表中元素的进出做了明确的要求。

栈中的元素只能从线性表的一端进出（另一端封死），且要遵循“先入后出”的原则，即先进栈的元素后出栈。



![栈结构示意图](http://data.biancheng.net/uploads/allimg/181118/1-1Q11QH634D9.gif)

<center>图 3 栈结构示意图</center>


栈结构如图 3 所示，像一个木桶，栈中含有 3 个元素，分别是 A、B 和 C，从在栈中的状态可以看出 A 最先进的栈，然后 B 进栈，最后 C 进栈。根据“先进后出”的原则，3 个元素出栈的顺序应该是：C 最先出栈，然后 B 出栈，最后才是 A 出栈。

队列中的元素只能从线性表的一端进，从另一端出，且要遵循“先入先出”的特点，即先进队列的元素也要先出队列。


![队列结构示意图](http://data.biancheng.net/uploads/allimg/181118/1-1Q11QHIJO.gif)

<center>图 4 队列结构示意图</center>

队列结构如图 4 所示，队列中有 3 个元素，分别是 A、B 和 C，从在队列中的状态可以看出是 A 先进队列，然后 B 进，最后 C 进。根据“先进先出”的原则，3 个元素出队列的顺序应该是 A 最先出队列，然后 B 出，最后 C 出。

**树存储结构**

树存储结构**适合存储具有“一对多**”关系的数据。

​                           																![家庭族谱](http://data.biancheng.net/uploads/allimg/181118/1-1Q11QJJ0142.gif)     

<center>图 5 家庭族谱</center>


如图 5 所示，其中张平只有一个父亲，但他却有两（多）个孩子，这就是“一对多”的关系，满足这种关系的数据可以使用树存储结构。

**图存储结构**

图存储结构适合存储**具有“多对多”关系**的数据。


![图存储结构示意图](http://data.biancheng.net/uploads/allimg/181118/1-1Q11QIFS44.gif)

<center>图 6 图存储结构示意图</center>

如图 6 所示，从 V1 可以到达 V2、V3、V4，同样，从 V2、V3、V4 也可以到达 V1，这就是“多对多”的关系，满足这种关系的数据可以使用图存储结构。

> 本节只是对数据结构中包含的各种存储结构做一个简要的介绍，各存储结构具体的实现会在后续文章中作详解介绍。



#### 二 线性表 

##### 1.1 什么是线性表 

线性表，全名为线性存储结构。使用线性表存储数据的方式可以这样理解，即“把所有数据用一根线儿[串](http://data.biancheng.net/view/175.html)起来，再存储到物理空间中”。

!["一对一"逻辑关系的数据](http://data.biancheng.net/uploads/allimg/181120/1-1Q120214QJ63.gif)

<center>图1 "一对一"逻辑关系的数据</center>


如图 1 所示，这是一组具有“一对一”关系的数据，我们接下来采用线性表将其储存到物理空间中。

首先，用“一根线儿”把它们按照顺序“串”起来，如图 2 所示：


![img](http://data.biancheng.net/uploads/allimg/181120/1-1Q12021551W22.gif)

<center>图 2 数据的"线性"结构</center>


图 2 中，左侧是“串”起来的数据，右侧是空闲的物理空间。把这“一串儿”数据放置到物理空间，我们可以选择以下两种方式，如图 3 所示。


![两种线性存储结构](http://data.biancheng.net/uploads/allimg/181120/1-1Q120215009361.gif)

<center>图 3 两种线性存储结构



图 3a) 是多数人想到的存储方式，而图 3b) 却少有人想到。我们知道，**数据存储的成功与否，取决于是否能将数据完整地复原成它本来的样子**。如果把图 3a) 和图 3b) 线的一头扯起，你会发现数据的位置依旧没有发生改变（和图 1 一样)。因此可以认定，这两种存储方式都是正确的。

将具有“一对一”关系的数据“线性”地存储到物理空间中，这种存储结构就称为线性存储结构（简称线性表）。

**使用线性表存储的数据，如同向数组中存储数据那样，要求数据类型必须一致**

> 也就是说，线性表存储的数据，要么全不都是整形，要么全部都是字符串。一半是整形，另一半是字符串的一组数据无法使用线性表存储。



**一 顺序存储结构和链式存储结构**

图 3 中我们可以看出，线性表存储数据可细分为以下 2 种：

1. 如图 3a) 所示，将数据依次存储在连续的整块物理空间中，这种存储结构称为顺序存储结构（简称顺序表）；
2. 如图 3b) 所示，数据分散的存储在物理空间中，通过一根线保存着它们之间的逻辑关系，这种存储结构称为链式存储结构（简称链表）；


也就是说，线性表存储结构可细分为顺序存储结构和链式存储结构。

**二 线性表常用术语**

数据结构中，一组数据中的每个个体被称为“数据元素”（简称“元素”）。例如，图 1 显示的这组数据，其中 1、2、3、4 和 5 都是这组数据钟的一个元素。

另外，对于具有“一对一”逻辑关系的数据，我们一直在用“某一元素的左侧（前边）或右侧（后边）”这样不专业的词，其实线性表中有更准确的术语：

- 某一元素的左侧相邻元素称为“直接前驱”，位于此元素左侧的所有元素都统称为“前驱元素”；
- 某一元素的右侧相邻元素称为“直接后继”，位于此元素右侧的所有元素都统称为“后继元素”；


以图 1 数据中的元素 3 来说，它的直接前驱是 2 ，此元素的前驱元素有 2 个，分别是 1 和 2；同理，此元素的直接后继是 4 ，后继元素也有 2 个，分别是 4 和 5。如图 4 所示：


![前驱和后继](http://data.biancheng.net/uploads/allimg/181120/1-1Q1202152464R.gif)

<center>图 4 前驱和后继</center>

##### 2.2 顺序表是什么 

顺序表，全名顺序存储结构，是线性表的一种。通过《线性表》一节的学习我们知道，线性表用于存储逻辑关系为“一对一”的数据，顺序表自然也不例外。

不仅如此，顺序表对数据的物理存储结构也有要求。顺序表存储数据时，会提前申请一整块足够大小的物理空间，然后将数据依次存储起来，存储时做到数据元素之间不留一丝缝隙。

例如，使用顺序表存储集合 `{1,2,3,4,5}`，数据最终的存储状态如图1 所示：


![img](http://data.biancheng.net/uploads/allimg/181121/2-1Q121202555F0.gif)

<center>图 1 顺序存储结构示意图


由此我们可以得出，将“具有 '一对一' 逻辑关系的数据按照次序连续存储到一整块物理空间上”的存储结构就是顺序存储结构。

通过观察图 1 中数据的存储状态，我们可以发现，顺序表存储数据同数组非常接近。其实，顺序表存储数据使用的就是数组。

>顺序表实现使用的是数组，但是两者性质不同，前者针对的是数据的存储，而后者是基本的数据类型

**一 顺序表的初始化**

使用顺序表存储数据之前，除了要申请足够大小的物理空间之外，为了方便后期使用表中的数据，顺序表还需要实时记录以下 2 项数据：

1. 顺序表申请的存储容量；
2. 顺序表的长度，也就是表中存储数据元素的个数；

提示：正常状态下，顺序表申请的存储容量要大于顺序表的长度。

因此，我们需要自定义顺序表，C 语言实现代码如下：

```c
typedef struct Table{    
    int * head;//声明了一个名为head的长度不确定的数组，也叫“动态数组”    
    int length;//记录当前顺序表的长度    
    int size;//记录顺序表分配的存储容量
}table;
```

注意，head 是我们声明的一个未初始化的动态数组，不要只把它看做是普通的指针。

接下来开始学习顺序表的初始化，也就是初步建立一个顺序表。建立顺序表需要做如下工作：

- 给 head 动态数据申请足够大小的物理空间；
- 给 size 和 length 赋初值；


因此，C 语言实现代码如下：

```c
#define Size 5 //对Size进行宏定义，表示顺序表申请空间的大小
table initTable(){    
    table t;   
    t.head = (int*)malloc(Size * sizeof(int));//构造一个空的顺序表，动态申请存储空间   
    if (!t.head) //如果申请失败，作出提示并直接退出程序   
    {        printf("初始化失败");     
     exit(0);    }   
    t.length = 0;//空表的长度初始化为0   
    t.size = Size;//空表的初始存储空间为Size   
    return t;}
```

我们看到，整个顺序表初始化的过程被封装到了一个函数中，此函数返回值是一个已经初始化完成的顺序表。这样做的好处是增加了代码的可用性，也更加美观。与此同时，顺序表初始化过程中，要注意对物理空间的申请进行判断，对申请失败的情况进行处理，这里只进行了“输出提示信息和强制退出”的操作，可以根据你自己的需要对代码中的 if 语句进行改进。

通过在主函数中调用 initTable 语句，就可以成功创建一个空的顺序表，与此同时我们还可以试着向顺序表中添加一些元素，C 语言实现代码如下：

```c
#include <stdio.h>
#include <stdlib.h>  //malloc()、exit()
#define Size 5
typedef struct Table {
    int * head;
    int length;
    int size;
}table;
table initTable() {
    table t;
    t.head = (int*)malloc(Size * sizeof(int));
    if (!t.head)
    {
        printf("初始化失败");
        exit(0);
    }
    t.length = 0;
    t.size = Size;
    return t;
}
//输出顺序表中元素的函数
void displayTable(table t) {
    int i;
    for (i = 0; i < t.length; i++) {
        printf("%d ", t.head[i]);
    }
    printf("\n");
}
int main() {
    int i;
    table t = initTable();
    //向顺序表中添加元素
    for (i = 1; i <= Size; i++) {
        t.head[i - 1] = i;
        t.length++;
    }
    printf("顺序表中存储的元素分别是：\n");
    displayTable(t);
    return 0;
}
```

程序运行结果如下：

```shell
顺序表中存储的元素分别是：
1 2 3 4 5
```

可以看到，顺序表初始化成功。



##### 2.3 顺序表的基本操作 

我们学习了顺序表及初始化的过程，本节学习有关顺序表的一些基本操作，以及如何使用 C 语言实现它们。

###### 2.3.1 顺序表插入元素

向已有顺序表中插入数据元素，根据插入位置的不同，可分为以下 3 种情况：

1. 插入到顺序表的表头；
2. 在表的中间位置插入元素；
3. 尾随顺序表中已有元素，作为顺序表中的最后一个元素；


虽然数据元素插入顺序表中的位置有所不同，但是都使用的是同一种方式去解决，即：通过遍历，找到数据元素要插入的位置，然后做如下两步工作：

- 将要插入位置元素以及后续的元素整体向后移动一个位置；
- 将元素放到腾出来的位置上；


例如，在 `{1,2,3,4,5}` 的第 3 个位置上插入元素 6，实现过程如下：

- 遍历至顺序表存储第 3 个数据元素的位置，如图 1 所示：


![找到目标元素位置](http://data.biancheng.net/uploads/allimg/181122/2-1Q122201300X8.gif)

<center>图 1 找到目标元素位置</center>

- 将元素 3 以及后续元素 4 和 5 整体向后移动一个位置，如图 2 所示：


![将插入位置腾出](http://data.biancheng.net/uploads/allimg/181122/2-1Q122201355232.gif)

<center>图 2 将插入位置腾出</center>

- 将新元素 6 放入腾出的位置，如图 3 所示：


![插入目标元素](http://data.biancheng.net/uploads/allimg/181122/2-1Q12220142H50.gif)

<center>图 3 插入目标元素</center>


因此，顺序表插入数据元素的 C 语言实现代码如下：

```c
//插入函数，其中，elem为插入的元素，add为插入到顺序表的位置
table addTable(table t, int elem, int add)
{
    int i;
    //①判断插入本身是否存在问题（如果插入元素位置比整张表的长度+1还大（如果相等，是尾随的情况），或者插入的位置本身不存在，程序作为提示并自动退出）
    if (add > t.length + 1 || add < 1) {
        printf("插入位置有问题");
        return t;
    }
    //②做插入操作时，首先需要看顺序表是否有多余的存储空间提供给插入的元素，如果没有，需要申请
    if (t.length == t.size) {
        t.head = (int *)realloc(t.head, (t.size + 1) * sizeof(int));
        if (!t.head) {
            printf("存储分配失败");
            return t;
        }
        t.size += 1;
    }
    //③插入操作，需要将从插入位置开始的后续元素，逐个后移
    for (i = t.length - 1; i >= add - 1; i--) {
        t.head[i + 1] = t.head[i];
    }
    //④后移完成后，直接将所需插入元素，添加到顺序表的相应位置
    t.head[add - 1] = elem;
    //⑤由于添加了元素，所以长度+1
    t.length++;	
    return t;
}
```

注意，**动态数组额外申请更多物理空间使用的是 realloc 函数。**并且，在实现后续元素整体后移的过程，**目标位置其实是有数据的，还是 3**，只是下一步新插入元素时会把旧元素直接覆盖。

>整体后裔只能从后像待插入位置顺序后移，反之不行。

###### 2.3.2  顺序表删除元素

从顺序表中删除指定元素，实现起来非常简单，只需找到目标元素，并将其后续所有元素整体前移 1 个位置即可。

后续元素整体前移一个位置，会直接将目标元素删除，可间接实现删除元素的目的。

例如，从 `{1,2,3,4,5}` 中删除元素 3 的过程如图 4 所示：


![img](http://data.biancheng.net/uploads/allimg/181122/2-1Q122201629521.gif)

<center>图 4 顺序表删除元素的过程示意图</center>


因此，顺序表删除元素的 C 语言实现代码为：

```c
table delTable(table t, int add) {
    int i;
    if (add > t.length || add < 1) {
        printf("被删除元素的位置有误");
        exit(0);
    }
    //删除操作
    for (i = add; i < t.length; i++) {
        t.head[i - 1] = t.head[i];
    }
    t.length--;
    return t;
}
```

###### 2.3.3 顺序表查找元素

顺序表中查找目标元素，可以使用多种查找算法实现，比如说[二分查找](http://data.biancheng.net/view/55.html)算法、插值查找算法等。

这里，我们选择[顺序查找](http://data.biancheng.net/view/54.html)算法，具体实现代码为：

```c
//查找函数，其中，elem表示要查找的数据元素的值
int selectTable(table t, int elem) {
    int i;
    for (i = 0; i < t.length; i++) {
        if (t.head[i] == elem) {
            return i + 1;
        }
    }
    return -1;//如果查找失败，返回-1
}
```

###### 2.3.4 顺序表更改元素

顺序表更改元素的实现过程是：

1. 找到目标元素；
2. 直接修改该元素的值；


顺序表更改元素的 C 语言实现代码为：

~~~c
//更改函数，其中，elem为要更改的元素，newElem为新的数据元素
table amendTable(table t, int elem, int newElem) {
    int add = selectTable(t, elem);
    t.head[add - 1] = newElem;//由于返回的是元素在顺序表中的位置，所以-1就是该元素在数组中的下标
    return t;
}
~~~

以上是顺序表使用过程中最常用的基本操作，这里给出本节完整的实现代码：

~~~c
#include <stdio.h>
#include <stdlib.h>
#define Size 5
typedef struct Table {
    int * head;
    int length;
    int size;
}table;
table initTable() {
    table t;
    t.head = (int*)malloc(Size * sizeof(int));
    if (!t.head)
    {
        printf("初始化失败");
        exit(0);
    }
    t.length = 0;
    t.size = Size;
    return t;
}
table addTable(table t, int elem, int add)
{
    int i;
    if (add > t.length + 1 || add < 1) {
        printf("插入位置有问题");
        return t;
    }
    if (t.length >= t.size) {
        t.head = (int *)realloc(t.head, (t.size + 1) * sizeof(int));
        if (!t.head) {
            printf("存储分配失败");
        }
        t.size += 1;
    }
    for (i = t.length - 1; i >= add - 1; i--) {
        t.head[i + 1] = t.head[i];
    }
    t.head[add - 1] = elem;
    t.length++;
    return t;
}
table delTable(table t, int add) {
    int i;
    if (add > t.length || add < 1) {
        printf("被删除元素的位置有误");
        exit(0);
    }
    for (i = add; i < t.length; i++) {
        t.head[i - 1] = t.head[i];
    }
    t.length--;
    return t;
}
int selectTable(table t, int elem) {
    int i;
    for (i = 0; i < t.length; i++) {
        if (t.head[i] == elem) {
            return i + 1;
        }
    }
    return -1;
}
table amendTable(table t, int elem, int newElem) {
    int add = selectTable(t, elem);
    t.head[add - 1] = newElem;
    return t;
}
void displayTable(table t) {
    int i;
    for (i = 0; i < t.length; i++) {
        printf("%d ", t.head[i]);
    }
    printf("\n");
}
int main() {
    int i, add;
    table t1 = initTable();
    for (i = 1; i <= Size; i++) {
        t1.head[i - 1] = i;
        t1.length++;
    }
    printf("原顺序表：\n");
    displayTable(t1);

    printf("删除元素1:\n");
    t1 = delTable(t1, 1);
    displayTable(t1);

    printf("在第2的位置插入元素5:\n");
    t1 = addTable(t1, 5, 2);
    displayTable(t1);

    printf("查找元素3的位置:\n");
    add = selectTable(t1, 3);
    printf("%d\n", add);

    printf("将元素3改为6:\n");
    t1 = amendTable(t1, 3, 6);
    displayTable(t1);
    return 0;
}
~~~

程序运行结果为：

~~~shell
原顺序表：
1 2 3 4 5
删除元素1:
2 3 4 5
在第2的位置插入元素5:
2 5 3 4 5
查找元素3的位置:
3
将元素3改为6:
2 5 6 4 5
~~~



##### 2.4 链表是什么


链表，别名链式存储结构或单链表，用于存储逻辑关系为 "一对一" 的数据。与顺序表不同，链表不限制数据的物理存储状态，换句话说，使用链表存储的数据元素，其**物理存储位置是随机的**。

例如，使用链表存储 `{1,2,3}`，数据的物理存储状态如图1 所示：


![链表随机存储数据](http://data.biancheng.net/uploads/allimg/181123/2-1Q12321231CA.gif)

<center>图 1 链表随机存储数据</center>


我们看到，图 1 根本无法体现出各数据之间的逻辑关系。对此，链表的解决方案是，每个数据元素在存储时都配备一个指针，用于指向自己的直接后继元素。如图 2 所示：


![各数据元素配备指针](http://data.biancheng.net/uploads/allimg/181123/2-1Q12321243O36.gif)

<center>图 2 各数据元素配备指针</center>


像图 2 这样，数据元素随机存储，并通过指针表示数据之间逻辑关系的存储结构就是链式存储结构。

###### 2.4.1 链表的节点

从图 2 可以看到，链表中每个数据的存储都由以下两部分组成：

1. 数据元素本身，其所在的区域称为数据域；
2. 指向直接后继元素的指针，所在的区域称为指针域；


即链表中存储各数据元素的结构如图 3 所示：


![img](http://data.biancheng.net/uploads/allimg/181123/2-1Q1232126112G.gif)

<center>图 3 节点结构</center>


图 3 所示的结构在链表中称为节点。也就是说，链表实际存储的是一个一个的节点，真正的数据元素包含在这些节点中，如图 4 所示：


![链表中的节点](http://data.biancheng.net/uploads/allimg/181123/2-1Q123212Q3337.gif)

<center>图 4 链表中的节点</center>


因此，链表中每个节点的具体实现，需要使用 C 语言中的结构体，具体实现代码为：

```c
typedef struct Link{
    char elem; //代表数据域
    struct Link * next; //代表指针域，指向直接后继元素
}link; //link为节点名，每个节点都是一个 link 结构体
```

提示，由于指针域中的指针要指向的也是一个节点，因此要声明为 Link 类型（这里要写成 `struct Link*` 的形式）。

>指针类型是指针所指向的数据类型

###### 2.4.2 头节点，头指针和首元节点

其实，图 4 所示的链表结构并不完整。一个完整的链表需要由以下几部分构成：

1. 头指针：一个普通的指针，它的特点是永远指向链表第一个节点的位置。很明显，头指针用于指明链表的位置，便于后期找到链表并使用表中的数据；
2. 节点：链表中的节点又细分为头节点、首元节点和其他节点：
   - 头节点：其实就是一个不存任何数据的空节点，通常作为链表的第一个节点。对于链表来说，头节点不是必须的，它的作用只是为了方便解决某些实际问题；
   - 首元节点：由于头节点（也就是空节点）的缘故，链表中称第一个存有数据的节点为首元节点。首元节点只是对链表中第一个存有数据节点的一个称谓，没有实际意义；
   - 其他节点：链表中其他的节点；


因此，一个存储 `{1,2,3}` 的完整链表结构如图 5 所示：


![完整的链表示意图](http://data.biancheng.net/uploads/allimg/181123/2-1Q123213124343.gif)

<center>图 5 完整的链表示意图</center>

> 注意：链表中有头节点时，头指针指向头节点；反之，若链表中没有头节点，则头指针指向首元节点。

明白了链表的基本结构，下面我们来学习如何创建一个链表。

###### 2.4.3 链表的创建（初始化）

创建一个链表需要做如下工作：

1. 声明一个头指针（如果有必要，可以声明一个头节点）；
2. 创建多个存储数据的节点，在创建的过程中，要随时与其前驱节点建立逻辑关系；


例如，创建一个存储 `{1,2,3,4}` 且无头节点的链表，C 语言实现代码如下：

```c
link * initLink() {
    int i;
    link * p = NULL;//创建头指针
    link * temp = (link*)malloc(sizeof(link));//创建首元节点
    //首元节点先初始化
    temp->elem = 1;
    temp->next = NULL;
    p = temp;//头指针指向首元节点
    //从第二个节点开始创建
    for (i = 2; i < 5; i++) {
        //创建一个新节点并初始化
        link *a = (link*)malloc(sizeof(link));
        a->elem = i;
        a->next = NULL;
        //将temp节点与新建立的a节点建立逻辑关系
        temp->next = a;
        //指针temp每次都指向新链表的最后一个节点，其实就是 a节点，这里写temp=a也对
        temp = temp->next;
    }
    //返回建立的节点，只返回头指针 p即可，通过头指针即可找到整个链表
    return p;
}
```

如果想创建一个存储 `{1,2,3,4}` 且含头节点的链表，则 C 语言实现代码为：

```c
link * initLink(){
    int i;
    link * p=(link*)malloc(sizeof(link));//创建一个头结点
    link * temp=p;//声明一个指针指向头结点，
    //生成链表
    for (i=1; i<5; i++) {
        link *a=(link*)malloc(sizeof(link));
        a->elem=i;
        a->next=NULL;
        temp->next=a;
        temp=temp->next;
    }
    return p;
}
```

>有无头结点在创建链表的区别
>
>有头结点 初始化 头结点 头指针  临时指针 然后生成时 利用 temp 作为中间指针 
>
>无头结点 生成 第一个结点 和 头指针

我们只需在主函数中调用 initLink 函数，即可轻松创建一个存储 `{1,2,3,4}` 的链表，C 语言完整代码如下：

```c
#include <stdio.h>
#include <stdlib.h>
//链表中节点的结构
typedef struct Link {
    int  elem;
    struct Link *next;
}link;
//初始化链表的函数
link * initLink();
//用于输出链表的函数
void display(link *p);

int main() {
    link*p = NULL;
    //初始化链表（1，2，3，4）
    printf("初始化链表为：\n");
    p = initLink();
    display(p);
    return 0;
}

link * initLink() {
    int i;
    link * p = NULL;//创建头指针
    link * temp = (link*)malloc(sizeof(link));//创建首元节点
    //首元节点先初始化
    temp->elem = 1;
    temp->next = NULL;
    p = temp;//头指针指向首元节点
    for (i = 2; i < 5; i++) {
        link *a = (link*)malloc(sizeof(link));
        a->elem = i;
        a->next = NULL;
        temp->next = a;
        temp = temp->next;
    }
    return p;
}
void display(link *p) {
    link* temp = p;//将temp指针重新指向头结点
    //只要temp指针指向的结点的next不是Null，就执行输出语句。
    while (temp) {
        printf("%d ", temp->elem);
        temp = temp->next;
    }
    printf("\n");
}
```

程序运行结果为：

```shell
初始化链表为：
1 2 3 4
```


注意，如果使用带有头节点创建链表的方式，则输出链表的 display 函数需要做适当地修改：(因为头结点elem为空)

```c
void display(link *p){
    link* temp=p;//将temp指针重新指向头结点
    //只要temp指针指向的结点的next不是Null，就执行输出语句。
    while (temp->next) {
        temp=temp->next;
        printf("%d",temp->elem);
    }
    printf("\n");
}
```

##### 2.5 链表的基本操作

本节将详细介绍对链表的一些基本操作，包括对链表中数据的添加、删除、查找（遍历）和更改。

注意，以下对链表的操作实现均建立在已创建好链表的基础上，创建链表的代码如下所示：

```c
//声明节点结构
typedef struct Link {
    int  elem;//存储整形元素
    struct Link *next;//指向直接后继元素的指针
}link;
//创建链表的函数
link * initLink() {
    link * p = (link*)malloc(sizeof(link));//创建一个头结点
    link * temp = p;//声明一个指针指向头结点，用于遍历链表
    int i = 0;
    //生成链表
    for (i = 1; i < 5; i++) {
        //创建节点并初始化
        link *a = (link*)malloc(sizeof(link));
        a->elem = i;
        a->next = NULL;
        //建立新节点与直接前驱节点的逻辑关系
        temp->next = a;
        temp = temp->next;
    }
    return p;
}
```

从实现代码中可以看到，该链表是一个具有头节点的链表。由于头节点本身不用于存储数据，因此在实现对链表中数据的"增删查改"时要引起注意。

###### 2.5.1 链表插入元素

同顺序表一样，向链表中增添元素，根据添加位置不同，可分为以下 3 种情况：

- 插入到链表的头部（头节点之后），作为首元节点；
- 插入到链表中间的某个位置；
- 插入到链表的最末端，作为链表中最后一个数据元素；


虽然新元素的插入位置不固定，但是链表插入元素的思想是固定的，只需做以下两步操作，即可将新元素插入到指定的位置：

1. 将新结点的 next 指针指向插入位置后的结点；
2. 将插入位置前结点的 next 指针指向插入结点；


例如，我们在链表 `{1,2,3,4}` 的基础上分别实现在头部、中间部位、尾部插入新元素 5，其实现过程如图 1 所示：


![链表中插入元素的 3 种情况示意图](http://data.biancheng.net/uploads/allimg/181124/2-1Q1242005532U.gif)

<center>图 1 链表中插入元素的 3 种情况示意图</center>


从图中可以看出，虽然新元素的插入位置不同，但实现插入操作的方法是一致的，都是先执行步骤 1 ，再执行步骤 2。

注意：链表插入元素的操作必须是先步骤 1，再步骤 2；反之，若先执行步骤 2，会导致插入位置后续的部分链表丢失，无法再实现步骤 1。

通过以上的讲解，我们可以尝试编写 C 语言代码来实现链表插入元素的操作：

```c
//p为原链表，elem表示新数据元素，add表示新元素要插入的位置
link * insertElem(link * p, int elem, int add) {
    link * temp = p;//创建临时结点temp
    link * c = NULL;
    int i = 0;
    //首先找到要插入位置的上一个结点
    for (i = 1; i < add; i++) {
        if (temp == NULL) {
            printf("插入位置无效\n");
            return p;
        }
        temp = temp->next;
    }
    //创建插入结点c
    c = (link*)malloc(sizeof(link));
    c->elem = elem;
    //向链表中插入结点
    c->next = temp->next;
    temp->next = c;
    return  p;
}
```

提示，insertElem 函数中加入一个 if 语句，用于判断用户输入的插入位置是否有效。例如，在已存储 `{1,2,3}` 的链表中，用户要求在链表中第 100 个数据元素所在的位置插入新元素，显然用户操作无效，此时就会触发 if 语句。

###### 2.5.2 链表删除元素

从链表中删除指定数据元素时，实则就是将存有该数据元素的节点从链表中摘除，但作为一名合格的程序员，要对存储空间负责，对不再利用的存储空间要及时释放。因此，从链表中删除数据元素需要进行以下 2 步操作：

1. 将结点从链表中摘下来;
2. 手动释放掉结点，回收被结点占用的存储空间;


其中，从链表上摘除某节点的实现非常简单，只需找到该节点的直接前驱节点 temp，执行一行程序：

```c
temp->next=temp->next->next;
```

例如，从存有 `{1,2,3,4}` 的链表中删除元素 3，则此代码的执行效果如图 2 所示：


![链表删除元素示意图](http://data.biancheng.net/uploads/allimg/181124/2-1Q124200Q3239.gif)

<center>图 2 链表删除元素示意图</center>


因此，链表删除元素的 C 语言实现如下所示：

```c
//p为原链表，add为要删除元素的值
link * delElem(link * p, int add) {
    link * temp = p;
    link * del = NULL;
    int i = 0;
    //temp指向被删除结点的上一个结点
    for (i = 1; i < add; i++) {
        temp = temp->next;
    }
    del = temp->next;//单独设置一个指针指向被删除结点，以防丢失
    temp->next = temp->next->next;//删除某个结点的方法就是更改前一个结点的指针域
    free(del);//手动释放该结点，防止内存泄漏
    return p;
}
```

我们可以看到，从链表上摘下的节点 del 最终通过 free 函数进行了手动释放。

###### 2.5.3 链表查找元素

在链表中查找指定数据元素，最常用的方法是：从表头依次遍历表中节点，用被查找元素与各节点数据域中存储的数据元素进行比对，直至比对成功或遍历至链表最末端的 `NULL`（比对失败的标志）。

因此，链表中查找特定数据元素的 C 语言实现代码为：

```c
//p为原链表，elem表示被查找元素、
int selectElem(link * p, int elem) {
    //新建一个指针t，初始化为头指针 p
    link * t = p;
    int i = 1;
    //由于头节点的存在，因此while中的判断为t->next
    while (t->next) {
        t = t->next;
        if (t->elem == elem) {
            return i;
        }
        i++;
    }
    //程序执行至此处，表示查找失败
    return -1;
}
```

注意，遍历有头节点的链表时，需避免头节点对测试数据的影响，因此在遍历链表时，建立使用上面代码中的遍历方法，直接越过头节点对链表进行有效遍历。

###### 2.5.4 链表更新元素

更新链表中的元素，只需通过遍历找到存储此元素的节点，对节点中的数据域做更改操作即可。

直接给出链表中更新数据元素的 C 语言实现代码：

```c
//更新函数，其中，add 表示更改结点在链表中的位置，newElem 为新的数据域的值
link *amendElem(link * p, int add, int newElem) {
    int i = 0;
    link * temp = p;
    temp = temp->next;//在遍历之前，temp指向首元结点
    //遍历到被删除结点
    for (i = 1; i < add; i++) {
        temp = temp->next;
    }
    temp->elem = newElem;
    return p;
}
```

###### 2.5.5 总结

以上内容详细介绍了对链表中数据元素做"增删查改"的实现过程及 C 语言代码，在此给出本节的完整可运行代码：

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Link {
    int  elem;
    struct Link *next;
}link;
link * initLink();
//链表插入的函数，p是链表，elem是插入的结点的数据域，add是插入的位置
link * insertElem(link * p, int elem, int add);
//删除结点的函数，p代表操作链表，add代表删除节点的位置
link * delElem(link * p, int add);
//查找结点的函数，elem为目标结点的数据域的值
int selectElem(link * p, int elem);
//更新结点的函数，newElem为新的数据域的值
link *amendElem(link * p, int add, int newElem);
void display(link *p);

int main() {
    link *p = NULL;
    int address;
    //初始化链表（1，2，3，4）
    printf("初始化链表为：\n");
    p = initLink();
    display(p);

    printf("在第4的位置插入元素5：\n");
    p = insertElem(p, 5, 4);
    display(p);

    printf("删除元素3:\n");
    p = delElem(p, 3);
    display(p);

    printf("查找元素2的位置为：\n");
    address = selectElem(p, 2);
    if (address == -1) {
        printf("没有该元素");
    }
    else {
        printf("元素2的位置为：%d\n", address);
    }
    printf("更改第3的位置上的数据为7:\n");
    p = amendElem(p, 3, 7);
    display(p);

    return 0;
}

link * initLink() {
    link * p = (link*)malloc(sizeof(link));//创建一个头结点
    link * temp = p;//声明一个指针指向头结点，用于遍历链表
    int i = 0;
    //生成链表
    for (i = 1; i < 5; i++) {
        link *a = (link*)malloc(sizeof(link));
        a->elem = i;
        a->next = NULL;
        temp->next = a;
        temp = temp->next;
    }
    return p;
}
link * insertElem(link * p, int elem, int add) {
    link * temp = p;//创建临时结点temp
    link * c = NULL;
    int i = 0;
    //首先找到要插入位置的上一个结点
    for (i = 1; i < add; i++) {
        if (temp == NULL) {
            printf("插入位置无效\n");
            return p;
        }
        temp = temp->next;
    }
    //创建插入结点c
    c = (link*)malloc(sizeof(link));
    c->elem = elem;
    //向链表中插入结点
    c->next = temp->next;
    temp->next = c;
    return  p;
}

link * delElem(link * p, int add) {
    link * temp = p;
    link * del = NULL;
    int i = 0;
    //遍历到被删除结点的上一个结点
    for (i = 1; i < add; i++) {
        temp = temp->next;
    }
    del = temp->next;//单独设置一个指针指向被删除结点，以防丢失
    temp->next = temp->next->next;//删除某个结点的方法就是更改前一个结点的指针域
    free(del);//手动释放该结点，防止内存泄漏
    return p;
}
int selectElem(link * p, int elem) {
    link * t = p;
    int i = 1;
    while (t->next) {
        t = t->next;
        if (t->elem == elem) {
            return i;
        }
        i++;
    }
    return -1;
}
link *amendElem(link * p, int add, int newElem) {
    int i = 0;
    link * temp = p;
    temp = temp->next;//tamp指向首元结点
    //temp指向被删除结点
    for (i = 1; i < add; i++) {
        temp = temp->next;
    }
    temp->elem = newElem;
    return p;
}
void display(link *p) {
    link* temp = p;//将temp指针重新指向头结点
    //只要temp指针指向的结点的next不是Null，就执行输出语句。
    while (temp->next) {
        temp = temp->next;
        printf("%d ", temp->elem);
    }
    printf("\n");
}
```

代码运行结果：

```
初始化链表为：
1 2 3 4
在第4的位置插入元素5：
1 2 3 5 4
删除元素3:
1 2 5 4
查找元素2的位置为：
元素2的位置为：2
更改第3的位置上的数据为7:
1 2 7 4
```



##### 2.6 顺序表和链表的优缺点(区别、特点)详解

顺序表和链表由于存储结构上的差异，导致它们具有不同的特点，适用于不同的场景。本节就来分析它们的特点，让读者明白 "在什么样的场景中使用哪种存储结构" 更能有效解决问题。

通过系统地学习顺序表和链表我们知道，虽然它们同属于线性表，但数据的存储结构有本质的不同：

- 顺序表存储数据，需预先申请一整块足够大的存储空间，然后将数据按照次序逐一存储，数据之间紧密贴合，不留一丝空隙，如图 1a) 所示；
- 链表的存储方式与顺序表截然相反，什么时候存储数据，什么时候才申请存储空间，数据之间的逻辑关系依靠每个数据元素携带的指针维持，如图 1b) 所示；

![顺序表和链表的存储结构对比](http://data.biancheng.net/uploads/allimg/181125/2-1Q12512244c10.gif)

<center>图 1 顺序表和链表的存储结构对比</center>


基于不同的存储结构，顺序表和链表有以下几种不同。

###### 2.6.1 开辟空间的方式

顺序表存储数据实行的是 "一次开辟，永久使用"，即存储数据之前先开辟好足够的存储空间，空间一旦开辟后期无法改变大小（使用动态数组的情况除外）。

而链表则不同，链表存储数据时一次只开辟存储一个节点的物理空间，如果后期需要还可以再申请。

因此，若只从开辟空间方式的角度去考虑，当存储数据的个数无法提前确定，又或是物理空间使用紧张以致无法一次性申请到足够大小的空间时，使用链表更有助于问题的解决。

###### 2.6.2 空间利用率

从空间利用率的角度上看，顺序表的空间利用率显然要比链表高。

这是因为，链表在存储数据时，每次只申请一个节点的空间，且空间的位置是随机的，如图 2 所示：


![链表结构易产生碎片](http://data.biancheng.net/uploads/allimg/181125/2-1Q12512255D10.gif)

<center>图 2 链表结构易产生碎片</center>


这种申请存储空间的方式会产生很多空间碎片，一定程序上造成了空间浪费。不仅如此，由于链表中每个数据元素都必须携带至少一个指针，因此，链表对所申请空间的利用率也没有顺序表高。

> 空间碎片，指的是某些容量很小（1KB 甚至更小）以致无法得到有效利用的物理空间。

###### 2.6.3 [时间复杂度](http://data.biancheng.net/view/2.html)

解决不同类型的问题，顺序表和链表对应的时间复杂度也不同。

根据顺序表和链表在存储结构上的差异，问题类型主要分为以下 2 类：

1. 问题中主要涉及访问元素的操作，元素的插入、删除和移动操作极少；
2. 问题中主要涉及元素的插入、删除和移动，访问元素的需求很少；


第 1 类问题适合使用顺序表。这是因为，顺序表中存储的元素可以使用数组下标直接访问，无需遍历整个表，因此使用顺序表访问元素的时间复杂度为 `O(1)`；而在链表中访问数据元素，需要从表头依次遍历，直到找到指定节点，花费的时间复杂度为 `O(n)`;

第 2 类问题则适合使用链表。链表中数据元素之间的逻辑关系靠的是节点之间的指针，当需要在链表中某处插入或删除节点时，只需改变相应节点的指针指向即可，无需大量移动元素，因此链表中插入、删除或移动数据所耗费的时间复杂度为 `O(1)`；而顺序表中，插入、删除和移动数据可能会牵涉到大量元素的整体移动，因此时间复杂度至少为 `O(n)`;

综上所述，不同类型的场景，选择合适的存储结构会使解决问题效率成倍数地提高。



##### 2.7 双向链表 及其创建

目前我们所学到的链表，无论是动态链表还是[静态链表](http://data.biancheng.net/view/163.html)，表中各节点中都只包含一个指针（游标），且都统一指向直接后继节点，通常称这类链表为单向链表（或单链表）。

虽然使用单链表能 100% 解决逻辑关系为 "一对一" 数据的存储问题，但在解决某些特殊问题时，单链表并不是效率最优的存储结构。比如说，某场景中需要大量地查找某结点的前趋结点，这种情况下使用单链表无疑是灾难性的，因为单链表更适合 "从前往后" 找，"从后往前" 找并不是它的强项。

对于逆向查找（从后往前）相关的问题，使用本节讲解的双向链表，会更加事半功倍。

双向链表，简称双链表。从名字上理解双向链表，即链表是 "双向" 的，如图 1 所示：


![双向链表结构示意图](http://data.biancheng.net/uploads/allimg/181128/2-1Q12R01Q63Q.gif)

<center>图 1 双向链表结构示意图</center>

所谓双向，指的是各节点之间的逻辑关系是双向的，但通常头指针只设置一个，除非实际情况需要，可以为最后一个节点再设置一个“头指针”。

根据图 1 不难看出，双向链表中各节点包含以下 3 部分信息（如图 2 所示）：

1. 指针域：用于指向当前节点的直接前驱节点；
2. 数据域：用于存储数据元素；
3. 指针域：用于指向当前节点的直接后继节点。


![双向链表的节点构成](http://data.biancheng.net/uploads/allimg/181128/2-1Q12R01910615.gif)

<center>图 2 双向链表的节点构成</center>


因此，双链表的节点结构用 C 语言实现为：

```c
typedef struct line{
    struct line * prior; //指向直接前趋
    int data;
    struct line * next; //指向直接后继
}line;
```

> 读者可根据实际场景的需要，调整数据域 data 的数据类型。

###### 2.7.1 双向链表的创建

同单链表相比，双链表仅是各节点多了一个用于指向直接前驱的指针域。因此，我们可以在单链表的基础轻松实现对双链表的创建。

和创建单链表不同的是，创建双向链表的过程中，每一个新节点都要和前驱节点之间建立两次链接，分别是：

- 将新节点的 prior 指针指向直接前驱节点；
- 将直接前驱节点的 next 指针指向新节点；


这里给出创建双向链表的 C 语言实现代码：

```c
line* initLine(line * head) {
    int i = 0;
    line * list = NULL;
    //创建一个首元节点，链表的头指针为head
    head = (line*)malloc(sizeof(line));
    //对节点进行初始化
    head->prior = NULL;
    head->next = NULL;
    head->data = 1;
    //声明一个指向首元节点的指针，方便后期向链表中添加新创建的节点
    list = head;
    for (i = 2; i <= 5; i++) {
        //创建新的节点并初始化
        line * body = (line*)malloc(sizeof(line));
        body->prior = NULL;
        body->next = NULL;
        body->data = i;

        //新节点与链表最后一个节点建立关系
        list->next = body;
        body->prior = list;
        //list永远指向链表中最后一个节点
        list = list->next;
    }
    //返回新创建的链表
    return head;
}
```


我们可以尝试着在 main 函数中输出创建的双链表，C 语言代码如下：

```c
#include <stdio.h>
#include <stdlib.h>
//节点结构
typedef struct line {
    struct line * prior;
    int data;
    struct line * next;
}line;
//双链表的创建函数
line* initLine(line * head);
//输出双链表的函数
void display(line * head);

int main() {
    //创建一个头指针
    line * head = NULL;
    //调用链表创建函数
    head = initLine(head);
    //输出创建好的链表
    display(head);
    //显示双链表的优点
    printf("链表中第 4 个节点的直接前驱是：%d", head->next->next->next->prior->data);
    return 0;
}
line* initLine(line * head) {
    int i = 0;
    line * list = NULL;
    //创建一个首元节点，链表的头指针为head
    head = (line*)malloc(sizeof(line));
    //对节点进行初始化
    head->prior = NULL;
    head->next = NULL;
    head->data = 1;
    //声明一个指向首元节点的指针，方便后期向链表中添加新创建的节点
    list = head;
    for (i = 2; i <= 5; i++) {
        //创建新的节点并初始化
        line * body = (line*)malloc(sizeof(line));
        body->prior = NULL;
        body->next = NULL;
        body->data = i;

        //新节点与链表最后一个节点建立关系
        list->next = body;
        body->prior = list;
        //list永远指向链表中最后一个节点
        list = list->next;
    }
    //返回新创建的链表
    return head;
}
void display(line * head) {
    line * temp = head;
    while (temp) {
        //如果该节点无后继节点，说明此节点是链表的最后一个节点
        if (temp->next == NULL) {
            printf("%d\n", temp->data);
        }
        else {
            printf("%d <-> ", temp->data);
        }
        temp = temp->next;
    }
}
```

程序运行结果：

```shell
1 <-> 2 <-> 3 <-> 4 <-> 5
链表中第 4 个节点的直接前驱是：3
```



##### 2.8 双向链表的基本操作

本节知识基于已熟练掌握双向链表创建过程的基础上，我们继续上节所创建的双向链表来学习本节内容，创建好的双向链表如图 1 所示：


![双向链表示意图](http://data.biancheng.net/uploads/allimg/181129/2-1Q12ZQIWK.gif)

<center>图 1 双向链表示意图</center>

###### 2.8.1 双向链表添加节点

根据数据添加到双向链表中的位置不同，可细分为以下 3 种情况：

一 添加至表头

将新数据元素添加到表头，只需要将该元素与表头元素建立双层逻辑关系即可。

换句话说，假设新元素节点为 temp，表头节点为 head，则需要做以下 2 步操作即可：

1. temp->next=head; head->prior=temp;
2. 将 head 移至 temp，重新指向新的表头；


例如，将新元素 7 添加至双链表的表头，则实现过程如图 2 所示：


![添加元素至双向链表的表头](http://data.biancheng.net/uploads/allimg/181129/2-1Q12ZQT5263.gif)

<center>图 2 添加元素至双向链表的表头</center>

二  添加至表的中间位置

同单链表添加数据类似，双向链表中间位置添加数据需要经过以下 2 个步骤，如图 3 所示：

1. 新节点先与其直接后继节点建立双层逻辑关系；
2. 新节点的直接前驱节点与之建立双层逻辑关系；


![双向链表中间位置添加数据元素](http://data.biancheng.net/uploads/allimg/181129/2-1Q12ZQ915562.gif)

<center>图 3 双向链表中间位置添加数据元素</center>

三  添加至表尾

与添加到表头是一个道理，实现过程如下（如图 4 所示）：

1. 找到双链表中最后一个节点；
2. 让新节点与最后一个节点进行双层逻辑关系；


![双向链表尾部添加数据元素](http://data.biancheng.net/uploads/allimg/181129/2-1Q12ZR0305L.gif)

<center>图 4 双向链表尾部添加数据元素</center>


因此，我们可以试着编写双向链表添加数据的 C 语言代码，参考代码如下：

```c
//data 为要添加的新数据，add 为添加到链表中的位置
line * insertLine(line * head, int data, int add) {
    //新建数据域为data的结点
    line * temp = (line*)malloc(sizeof(line));
    temp->data = data;
    temp->prior = NULL;
    temp->next = NULL;
    //插入到链表头，要特殊考虑
    if (add == 1) {
        temp->next = head;
        head->prior = temp;
        head = temp;
    }
    else {
        int i = 0;
        line * body = head;
        //找到要插入位置的前一个结点
        for (i = 1; i < add - 1; i++) {
            body = body->next;
            if (body == NULL) {
                printf("插入位置有误\n");
                break;
            }
        }
        if (body) {
            //判断条件为真，说明插入位置为链表尾
            if (body->next == NULL) {
                body->next = temp;
                temp->prior = body;
            }
            else {
                body->next->prior = temp;
                temp->next = body->next;
                body->next = temp;
                temp->prior = body;
            }
        }
    }
    return head;
}
```

###### 2.8.2 双向链表删除节点

双链表删除结点时，只需遍历链表找到要删除的结点，然后将该节点从表中摘除即可。

例如，从图 1 基础上删除元素 2 的操作过程如图 5 所示：



![双链表删除元素操作示意图](http://data.biancheng.net/uploads/allimg/181129/2-1Q12ZR10D13.gif)

<center>图 5 双链表删除元素操作示意图</center>


双向链表删除节点的 C 语言实现代码如下：

```c
//删除结点的函数，data为要删除结点的数据域的值
line * delLine(line * head, int data) {
    line * temp = head;
    //遍历链表
    while (temp) {
        //判断当前结点中数据域和data是否相等，若相等，摘除该结点
        if (temp->data == data) {
            temp->prior->next = temp->next;
            temp->next->prior = temp->prior;
            free(temp);
            return head;
        }
        temp = temp->next;
    }
    printf("链表中无该数据元素\n");
    return head;
}
```

###### 2.8.3 双向链表查找节点

通常，双向链表同单链表一样，都仅有一个头指针。因此，双链表查找指定元素的实现同单链表类似，都是从表头依次遍历表中元素。

C 语言实现代码为：

```c
//head为原双链表，elem表示被查找元素
int selectElem(line * head, int elem) {
    //新建一个指针t，初始化为头指针 head
    line * t = head;
    int i = 1;
    while (t) {
        if (t->data == elem) {
            return i;
        }
        i++;
        t = t->next;
    }
    //程序执行至此处，表示查找失败
    return -1;
}
```

###### 2.8.4 双向链表更改节点

更改双链表中指定结点数据域的操作是在查找的基础上完成的。实现过程是：通过遍历找到存储有该数据元素的结点，直接更改其数据域即可。

实现此操作的 C 语言实现代码如下：

```c
//更新函数，其中，add 表示更改结点在双链表中的位置，newElem 为新数据的值
line *amendElem(line * p, int add, int newElem) {
    int i = 0;
    line * temp = p;
    //遍历到被删除结点
    for (i = 1; i < add; i++) {
        temp = temp->next;
        if (temp == NULL) {
            printf("更改位置有误！\n");
            break;
        }
    }
    if (temp) {
        temp->data = newElem;
    }
    return p;
}
```

###### 2.8.5 总结

这里给出双链表中对数据进行 "增删查改" 操作的完整实现代码：

```c
#include <stdio.h>
#include <stdlib.h>
typedef struct line {
    struct line * prior;
    int data;
    struct line * next;
}line;
//双链表的创建
line* initLine(line * head);
//双链表插入元素，add表示插入位置
line * insertLine(line * head, int data, int add);
//双链表删除指定元素
line * delLine(line * head, int data);
//双链表中查找指定元素
int selectElem(line * head, int elem);
//双链表中更改指定位置节点中存储的数据，add表示更改位置
line *amendElem(line * p, int add, int newElem);
//输出双链表的实现函数
void display(line * head);
int main() {
    line * head = NULL;
    //创建双链表
    printf("初始链表为：\n");
    head = initLine(head);
    display(head);
    //在表中第 3 的位置插入元素 7
    printf("在表中第 3 的位置插入新元素 7：\n");
    head = insertLine(head, 7, 3);
    display(head);
    //表中删除元素 2
    printf("删除元素 2：\n");
    head = delLine(head, 2);
    display(head);

    printf("元素 3 的位置是：%d\n", selectElem(head, 3));
    //表中第 3 个节点中的数据改为存储 6
    printf("将第 3 个节点存储的数据改为 6：\n");
    head = amendElem(head, 3, 6);
    display(head);
    return 0;
}
line* initLine(line * head) {
    int i = 0;
    line * list = NULL;
    head = (line*)malloc(sizeof(line));
    head->prior = NULL;
    head->next = NULL;
    head->data = 1;
    list = head;
    for (i = 2; i <= 3; i++) {
        line * body = (line*)malloc(sizeof(line));
        body->prior = NULL;
        body->next = NULL;
        body->data = i;

        list->next = body;
        body->prior = list;
        list = list->next;
    }
    return head;
}
line * insertLine(line * head, int data, int add) {
    //新建数据域为data的结点
    line * temp = (line*)malloc(sizeof(line));
    temp->data = data;
    temp->prior = NULL;
    temp->next = NULL;
    //插入到链表头，要特殊考虑
    if (add == 1) {
        temp->next = head;
        head->prior = temp;
        head = temp;
    }
    else {
        int i = 0;
        line * body = head;
        //找到要插入位置的前一个结点
        for (i = 1; i < add - 1; i++) {
            body = body->next;
            if (body == NULL) {
                printf("插入位置有误\n");
                break;
            }
        }
        if (body) {
            //判断条件为真，说明插入位置为链表尾
            if (body->next == NULL) {
                body->next = temp;
                temp->prior = body;
            }
            else {
                body->next->prior = temp;
                temp->next = body->next;
                body->next = temp;
                temp->prior = body;
            }
        }
    }
    return head;
}
line * delLine(line * head, int data) {
    line * temp = head;
    //遍历链表
    while (temp) {
        //判断当前结点中数据域和data是否相等，若相等，摘除该结点
        if (temp->data == data) {
            temp->prior->next = temp->next;
            temp->next->prior = temp->prior;
            free(temp);
            return head;
        }
        temp = temp->next;
    }
    printf("链表中无该数据元素\n");
    return head;
}
//head为原双链表，elem表示被查找元素
int selectElem(line * head, int elem) {
    //新建一个指针t，初始化为头指针 head
    line * t = head;
    int i = 1;
    while (t) {
        if (t->data == elem) {
            return i;
        }
        i++;
        t = t->next;
    }
    //程序执行至此处，表示查找失败
    return -1;
}
//更新函数，其中，add 表示更改结点在双链表中的位置，newElem 为新数据的值
line *amendElem(line * p, int add, int newElem) {
    int i = 0;
    line * temp = p;
    //遍历到被删除结点
    for (i = 1; i < add; i++) {
        temp = temp->next;
        if (temp == NULL) {
            printf("更改位置有误！\n");
            break;
        }
    }
    if (temp) {
        temp->data = newElem;
    }
    return p;
}
//输出链表的功能函数
void display(line * head) {
    line * temp = head;
    while (temp) {
        if (temp->next == NULL) {
            printf("%d\n", temp->data);
        }
        else {
            printf("%d->", temp->data);
        }
        temp = temp->next;
    }
}
```

程序执行结果为：

```
初始链表为：
1->2->3
在表中第 3 的位置插入新元素 7：
1->2->7->3
删除元素 2：
1->7->3
元素 3 的位置是：3
将第 3 个节点存储的数据改为 6：
1->7->6
```



#### 三 栈和队列

##### 3.1 什么是栈

同顺序表和链表

一样，栈也是用来存储逻辑关系为 "一对一" 数据的线性存储结构，如图 1 所示。


![栈存储结构示意图](http://data.biancheng.net/uploads/allimg/181201/2-1Q201203Q5110.gif)

<center>图 1 栈存储结构示意图</center>


从图 1 我们看到，栈存储结构与之前所学的线性存储结构有所差异，这缘于栈对数据 "存" 和 "取" 的过程有特殊的要求：

1. 栈只能从表的一端存取数据，另一端是封闭的，如图 1 所示；
2. 在栈中，无论是存数据还是取数据，都必须遵循"先进后出"的原则，即最先进栈的元素最后出栈。拿图 1 的栈来说，从图中数据的存储状态可判断出，元素 1 是最先进的栈。因此，当需要从栈中取出元素 1 时，根据"先进后出"的原则，需提前将元素 3 和元素 2 从栈中取出，然后才能成功取出元素 1。


因此，我们可以给栈下一个定义，即栈是一种只能从表的一端存取数据且遵循 "先进后出" 原则的线性存储结构。

通常，栈的开口端被称为栈顶；相应地，封口端被称为栈底。因此，栈顶元素指的就是距离栈顶最近的元素，拿图 2 来说，栈顶元素为元素 4；同理，栈底元素指的是位于栈最底部的元素，图 2 中的栈底元素为元素 1。


![栈顶和栈底](http://data.biancheng.net/uploads/allimg/181201/2-1Q201204153P8.gif)

<center>图 2 栈顶和栈底</center>

###### 3.1.1 进栈和出栈

基于栈结构的特点，在实际应用中，通常只会对栈执行以下两种操作：

- 向栈中添加元素，此过程被称为"进栈"（入栈或压栈）；
- 从栈中提取出指定元素，此过程被称为"出栈"（或弹栈）；

###### 3.1.2 栈的具体实现

栈是一种 "特殊" 的线性存储结构，因此栈的具体实现有以下两种方式：

1. [顺序栈](http://data.biancheng.net/view/170.html)：采用顺序存储结构可以模拟栈存储数据的特点，从而实现栈存储结构；
2. [链栈](http://data.biancheng.net/view/171.html)：采用链式存储结构实现栈结构；

两种实现方式的区别，仅限于数据元素在实际物理空间上存放的相对位置，顺序栈底层采用的是数组，链栈底层采用的是链表。有关顺序栈和链栈的具体实现会在后续章节中作详细讲解。

###### 3.1.3 栈的应用

基于栈结构对数据存取采用 "先进后出" 原则的特点，它可以用于实现很多功能。

例如，我们经常使用浏览器在各种网站上查找信息。假设先浏览的页面 A，然后关闭了页面 A 跳转到页面 B，随后又关闭页面 B 跳转到了页面 C。而此时，我们如果想重新回到页面 A，有两个选择：

- 重新搜索找到页面 A；
- 使用浏览器的"回退"功能。浏览器会先回退到页面 B，而后再回退到页面 A。


浏览器 "回退" 功能的实现，底层使用的就是栈存储结构。当你关闭页面 A 时，浏览器会将页面 A 入栈；同样，当你关闭页面 B 时，浏览器也会将 B入栈。因此，当你执行回退操作时，才会首先看到的是页面 B，然后是页面 A，这是栈中数据依次出栈的效果。

不仅如此，栈存储结构还可以帮我们检测代码中的[括号匹配](http://data.biancheng.net/view/87.html)问题。多数编程语言都会用到括号（小括号、中括号和大括号），括号的错误使用（通常是丢右括号）会导致程序编译错误，而很多开发工具中都有检测代码是否有编辑错误的功能，其中就包含检测代码中的括号匹配问题，此功能的底层实现使用的就是栈结构。

同时，栈结构还可以实现数值的[进制转换](http://data.biancheng.net/view/86.html)功能。例如，编写程序实现从十进制数自动转换成二进制数，就可以使用栈存储结构来实现。

以上也仅是栈应用领域的冰山一角，这里不再过多举例。在后续章节的学习中，我们会大量使用到栈结构。

接下来，我们学习如何实现顺序栈和链栈，以及对栈中元素进行入栈和出栈的操作。



##### 3.2 顺序栈的基本操作 

顺序栈，即用顺序表实现栈存储结构。通过前面的学习我们知道，使用栈存储结构操作数据元素必须遵守 "先进后出" 的原则，本节就 "如何使用顺序表模拟栈以及实现对栈中数据的基本操作（出栈和入栈）" 给大家做详细介绍。

如果你仔细观察顺序表（底层实现是数组](http://data.biancheng.net/view/181.html)）和栈结构就会发现，它们存储数据的方式高度相似，只不过栈对数据的存取过程有特殊的限制，而顺序表没有。

例如，我们先使用顺序表（a 数组）存储 `{1,2,3,4}`，存储状态如图1 所示：


![顺序表存储 {1,2,3,4}](http://data.biancheng.net/uploads/allimg/181202/2-1Q202131155H8.gif)

<center>图 1 顺序表存储 {1,2,3,4}</center>


同样，使用栈存储结构存储 `{1,2,3,4}`，其存储状态如图 2 所示：


![栈结构存储 {1,2,3,4}](http://data.biancheng.net/uploads/allimg/181202/2-1Q202131233249.gif)

<center>图 2 栈结构存储 {1,2,3,4}</center>


通过图 1 和图 2 的对比不难看出，使用顺序表模拟栈结构很简单，只需要将数据从 a 数组下标为 0 的位置依次存储即可。

从数组下标为 0 的模拟栈存储数据是常用的方法，从其他数组下标处存储数据也完全可以，这里只是为了方便初学者理解。

了解了顺序表模拟栈存储数据后，接下来看如何模拟栈中元素出栈的操作。由于栈对存储元素出栈的次序有"先进后出"的要求，如果想将图 1 中存储的元素 1 从栈中取出，需先将元素 4、元素 3 和元素 2 依次从栈中取出。

这里给出使用顺序表模拟栈存储结构常用的实现思路，即在顺序表中设定一个实时指向栈顶元素的变量（一般命名为 top），top 初始值为 -1，表示栈中没有存储任何数据元素，及栈是"空栈"。一旦有数据元素进栈，则 top 就做 +1 操作；反之，如果数据元素出栈，top 就做 -1 操作。

###### 3.2.1 顺序栈元素"入栈"

比如，还是模拟栈存储 `{1,2,3,4}` 的过程。最初，栈是"空栈"，即数组是空的，top 值为初始值 -1，如图 3 所示：


![空栈示意图](http://data.biancheng.net/uploads/allimg/181202/2-1Q202131603419.gif)

<center>图 3 空栈示意图</center>


首先向栈中添加元素 1，我们默认数组下标为 0 一端表示栈底，因此，元素 1 被存储在数组 a[1] 处，同时 top 值 +1，如图 4 所示：


![模拟栈存储元素 1](http://data.biancheng.net/uploads/allimg/181202/2-1Q2021316322O.gif)

<center>图 4 模拟栈存储元素 1</center>


采用以上的方式，依次存储元素 2、3 和 4，最终，top 值变为 3，如图 5 所示：


![模拟栈存储{1,2,3,4}](http://data.biancheng.net/uploads/allimg/181202/2-1Q202131649636.gif)

<center>图 5 模拟栈存储{1,2,3,4}</center>


因此，C 语言实现代码为：

```c
//元素elem进栈，a为数组，top值为当前栈的栈顶位置
int push(int* a,int top,int elem){
    a[++top]=elem;
    return top;
}
```

代码中的 a[++top]=elem，等价于先执行 ++top，再执行 a[top]=elem。

###### 3.2.2 顺序栈元素"出栈"

其实，top 变量的设置对模拟数据的 "入栈" 操作没有实际的帮助，它是为实现数据的 "出栈" 操作做准备的。

比如，将图 5 中的元素 2 出栈，则需要先将元素 4 和元素 3 依次出栈。需要注意的是，当有数据出栈时，要将 top 做 -1 操作。因此，元素 4 和元素 3 出栈的过程分别如图 6a) 和 6b) 所示：


![数据元素出栈](http://data.biancheng.net/uploads/allimg/181225/2-1Q225200HMC.gif)

<center>图 6 数据元素出栈</center>

注意，图 6 数组中元素的消失仅是为了方便初学者学习，其实，这里只需要对 top 值做 -1 操作即可，因为 top 值本身就表示栈的栈顶位置，因此 top-1 就等同于栈顶元素出栈。并且后期向栈中添加元素时，新元素会存储在类似元素 4 这样的旧元素位置上，将旧元素覆盖。

元素 4 和元素 3 全部出栈后，元素 2 才能出栈。因此，使用顺序表模拟数据出栈操作的 C 语言实现代码为：

```c
//数据元素出栈
int pop(int * a,int top){
    if (top==-1) {
        printf("空栈");
        return -1;
    }
    printf("弹栈元素：%d\n",a[top]);
    top--;
    return top;
}
```

代码中的 if 语句是为了防止用户做 "栈中已无数据却还要数据出栈" 的错误操作。代码中，关于对栈中元素出栈操作的实现，只需要 top 值 -1 即可。

###### 3.2.3 总结

通过学习顺序表模拟栈中数据入栈和出栈的操作，初学者完成了对顺序栈的学习，这里给出顺序栈及对数据基本操作的 C 语言完整代码：

```c
#include <stdio.h>
//元素elem进栈
int push(int* a,int top,int elem){
    a[++top]=elem;
    return top;
}
//数据元素出栈
int pop(int * a,int top){
    if (top==-1) {
        printf("空栈");
        return -1;
    }
    printf("弹栈元素：%d\n",a[top]);
    top--;
    return top;
}
int main() {
    int a[100];
    int top=-1;
    top=push(a, top, 1);
    top=push(a, top, 2);
    top=push(a, top, 3);
    top=push(a, top, 4);
    top=pop(a, top);
    top=pop(a, top);
    top=pop(a, top);
    top=pop(a, top);
    top=pop(a, top);
    return 0;
}
```

程序输出结果为：

```shell
弹栈元素：4
弹栈元素：3
弹栈元素：2
弹栈元素：1
空栈
```

##### 3.3  链栈的基本操作(入栈和出栈)

链栈，即用链表实现栈存储结构。

链栈的实现思路同[顺序栈](http://data.biancheng.net/view/170.html)类似，顺序栈是将数顺序表（数组）的一端作为栈底，另一端为栈顶；链栈也如此，通常我们将链表的头部作为栈顶，尾部作为栈底，如图 1 所示：


![链栈示意图](http://data.biancheng.net/uploads/allimg/181202/2-1Q2021G31YC.gif)

<center>图 1 链栈示意图</center>

> 将链表头部作为栈顶的一端，可以避免在实现数据 "入栈" 和 "出栈" 操作时做大量遍历链表的耗时操作。

链表的头部作为栈顶，意味着：

- 在实现数据"入栈"操作时，需要将数据从链表的头部插入；
- 在实现数据"出栈"操作时，需要删除链表头部的首元节点；


**因此，链栈实际上就是一个只能采用头插法插入或删除数据的链表。**

###### 3.3.1 链栈元素入栈

例如，将元素 1、2、3、4 依次入栈，等价于将各元素采用头插法依次添加到链表中，每个数据元素的添加过程如图 2 所示：


![链栈元素依次入栈过程示意图](http://data.biancheng.net/uploads/allimg/181202/2-1Q2021G402604.gif)

<center>图 2 链栈元素依次入栈过程示意图</center>


C语言实现代码为：

```c
//链表中的节点结构
typedef struct lineStack{
    int data;
    struct lineStack * next;
}lineStack;
//stack为当前的链栈，a表示入栈元素
lineStack* push(lineStack * stack,int a){
    //创建存储新元素的节点
    lineStack * line=(lineStack*)malloc(sizeof(lineStack));
    line->data=a;
    //新节点与头节点建立逻辑关系
    line->next=stack;
    //更新头指针的指向
    stack=line;
    return stack;
}
```

###### 3.3.2  链栈元素出栈

例如，图 2e) 所示的链栈中，若要将元素 3 出栈，根据"先进后出"的原则，要先将元素 4 出栈，也就是从链表中摘除，然后元素 3 才能出栈，整个操作过程如图 3 所示：


![链栈元素出栈示意图](http://data.biancheng.net/uploads/allimg/181202/2-1Q2021G432217.gif)

<center>图 3 链栈元素出栈示意图</center> 


因此，实现栈顶元素出链栈的 C 语言实现代码为：

```c
//栈顶元素出链栈的实现函数
lineStack * pop(lineStack * stack){
    if (stack) {
        //声明一个新指针指向栈顶节点
        lineStack * p=stack;
        //更新头指针
        stack=stack->next;
        printf("出栈元素：%d ",p->data);
        if (stack) {
            printf("新栈顶元素：%d\n",stack->data);
        }else{
            printf("栈已空\n");
        }
        free(p);
    }else{
        printf("栈内没有元素");
        return stack;
    }
    return stack;
}
```

代码中通过使用 if 判断语句，避免了用户执行"栈已空却还要数据出栈"错误操作。

###### 3.3.3 总结

本节，通过采用头插法操作数据的单链表实现了链栈结构，这里给出链栈及基本操作的C语言完整代码：

```c
#include <stdio.h>
#include <stdlib.h>
typedef struct lineStack{
    int data;
    struct lineStack * next;
}lineStack;
lineStack* push(lineStack * stack,int a){
    lineStack * line=(lineStack*)malloc(sizeof(lineStack));
    line->data=a;
    line->next=stack;
    stack=line;
    return stack;
}
lineStack * pop(lineStack * stack){
    if (stack) {
        lineStack * p=stack;
        stack=stack->next;
        printf("弹栈元素：%d ",p->data);
        if (stack) {
            printf("栈顶元素：%d\n",stack->data);
        }else{
            printf("栈已空\n");
        }
        free(p);
    }else{
        printf("栈内没有元素");
        return stack;
    }
    return stack;
}
int main() {
    lineStack * stack=NULL;
    stack=push(stack, 1);
    stack=push(stack, 2);
    stack=push(stack, 3);
    stack=push(stack, 4);
    stack=pop(stack);
    stack=pop(stack);
    stack=pop(stack);
    stack=pop(stack);
    stack=pop(stack);
    return 0;
}
```

程序运行结果为：

```shell
弹栈元素：4 栈顶元素：3
弹栈元素：3 栈顶元素：2
弹栈元素：2 栈顶元素：1
弹栈元素：1 栈已空
栈内没有元素
```



##### 3.4 什么是队列 

队列，和栈一样，也是一种对数据的"存"和"取"有严格要求的线性存储结构。与栈结构不同的是，队列的两端都"开口"，要求数据只能从一端进，从另一端出，如图 1 所示：


![队列存储结构](http://data.biancheng.net/uploads/allimg/181203/2-1Q203200556309.gif)

<center>图 1 队列存储结构</center>

通常，称进数据的一端为 "队尾"，出数据的一端为 "队头"，数据元素进队列的过程称为 "入队"，出队列的过程称为 "出队"。

不仅如此，队列中数据的进出要遵循 "先进先出" 的原则，即最先进队列的数据元素，同样要最先出队列。拿图 1 中的队列来说，从数据在队列中的存储状态可以分析出，元素 1 最先进队，其次是元素 2，最后是元素 3。此时如果将元素 3 出队，根据队列 "先进先出" 的特点，元素 1 要先出队列，元素 2 再出队列，最后才轮到元素 3 出队列。

栈和队列不要混淆，栈结构是一端封口，特点是"先进后出"；而队列的两端全是开口，特点是"先进先出"。

因此，数据从表的一端进，从另一端出，且遵循 "先进先出" 原则的线性存储结构就是队列。

###### 3.4.1 队列的实现

队列存储结构的实现有以下两种方式：

1. [顺序队列](http://data.biancheng.net/view/173.html)：在顺序表的基础上实现的队列结构；
2. [链队列](http://data.biancheng.net/view/174.html)：在链表的基础上实现的队列结构；


两者的区别仅是顺序表和链表的区别，即在实际的物理空间中，数据集中存储的队列是顺序队列，分散存储的队列是链队列。

###### 3.4.2 队列的实际应用

实际生活中，队列的应用随处可见，比如排队买 XXX、医院的挂号系统等，采用的都是队列的结构。

拿排队买票来说，所有的人排成一队，先到者排的就靠前，后到者只能从队尾排队等待，队中的每个人都必须等到自己前面的所有人全部买票成功并从队头出队后，才轮到自己买票。这就不是典型的队列结构吗？

明白了什么是队列，接下来开始系统地学习顺序队列和链队列。



##### 3.5 顺序队列及其（C语言）实现详解

顺序队列，即采用顺序表模拟实现的队列结构。

我们知道，队列具有以下两个特点：

1. 数据从队列的一端进，另一端出；
2. 数据的入队和出队遵循"先进先出"的原则；


因此，只要使用顺序表按以上两个要求操作数据，即可实现顺序队列。首先来学习一种最简单的实现方法。

###### 3.5.1 顺序队列简单实现

由于顺序队列的底层使用的是数组，因此需预先申请一块足够大的内存空间初始化顺序队列。除此之外，为了满足顺序队列中数据从队尾进，队头出且先进先出的要求，我们还需要定义两个指针（top 和 rear）分别用于指向顺序队列中的队头元素和队尾元素，如图1 所示：


![顺序队列实现示意图](http://data.biancheng.net/uploads/allimg/181204/2-1Q204202R4539.gif)

<center>图 1 顺序队列实现示意图</center>


由于顺序队列初始状态没有存储任何元素，因此 top 指针和 rear 指针重合，且由于顺序队列底层实现靠的是数组，因此 top 和 rear 实际上是两个变量，它的值分别是队头元素和队尾元素所在数组位置的下标。

在图 1 的基础上，当有数据元素进队列时，对应的实现操作是将其存储在指针 rear 指向的数组位置，然后 rear+1；当需要队头元素出队时，仅需做 top+1 操作。

例如，在图 1 基础上将 `{1,2,3,4}` 用顺序队列存储的实现操作如图 2 所示：


![数据进顺序队列的过程实现示意图](http://data.biancheng.net/uploads/allimg/181204/2-1Q20420293O01.gif)

<center>图 2 数据进顺序队列的过程实现示意图</center>


在图 2 基础上，顺序队列中数据出队列的实现过程如图 3 所示：


![数据出顺序队列的过程示意图](http://data.biancheng.net/uploads/allimg/181204/2-1Q204202950120.gif)

<center>图 3 数据出顺序队列的过程示意图</center>


因此，使用顺序表实现顺序队列最简单方法的 C 语言实现代码为：

```c
#include <stdio.h>
int enQueue(int *a,int rear,int data){
    a[rear]=data;
    rear++;
    return rear;
}
void deQueue(int *a,int front,int rear){
    //如果 front==rear，表示队列为空
    while (front!=rear) {
        printf("出队元素：%d\n",a[front]);
        front++;
    }
}
int main() {
    int a[100];
    int front,rear;
    //设置队头指针和队尾指针，当队列中没有元素时，队头和队尾指向同一块地址
    front=rear=0;
    //入队
    rear=enQueue(a, rear, 1);
    rear=enQueue(a, rear, 2);
    rear=enQueue(a, rear, 3);
    rear=enQueue(a, rear, 4);
    //出队
    deQueue(a, front, rear);
    return 0;
}
```

程序输出结果：

```
出队元素：1
出队元素：2
出队元素：3
出队元素：4
```



###### 3.5.2 此方法存在的问题

先来分析以下图 2b) 和图 3b)。图 2b) 是所有数据进队成功的示意图，而图 3b) 是所有数据全部出队后的示意图。通过对比两张图，你会发现，指针 top 和 rear 重合位置指向了 a[4] 而不再是 a[0]。也就是说，整个顺序队列在数据不断地进队出队过程中，在顺序表中的位置不断后移。

顺序队列整体后移造成的影响是：

- 顺序队列之前的数组存储空间将无法再被使用，造成了空间浪费；
- 如果顺序表申请的空间不足够大，则直接造成程序中数组 a 溢出，产生溢出错误；


为了避免以上两点，我建议初学者使用下面的方法实现顺序队列。

###### 3.5.3 顺序队列另一种实现方法

既然明白了上面这种方法的弊端，那么我们可以试着在它的基础上对其改良。

为了解决以上两个问题，可以使用巧妙的方法将顺序表打造成一个环状表，如图 4 所示：


![环状顺序队列](http://data.biancheng.net/uploads/allimg/181204/2-1Q204203432215.gif)

<center>图 4 环状顺序队列</center> 


图 4 只是一个想象图，在真正的实现时，没必要真创建这样一种结构，我们还是使用之前的顺序表，也还是使用之前的程序，只需要对其进行一点小小的改变：

```c
#include <stdio.h>
#define max 5//表示顺序表申请的空间大小
int enQueue(int *a,int front,int rear,int data){
    //添加判断语句，如果rear超过max，则直接将其从a[0]重新开始存储，如果rear+1和front重合，则表示数组已满
    if ((rear+1)%max==front) {
        printf("空间已满");
        return rear;
    }
    a[rear%max]=data;
    rear++;
    return rear;
}
int  deQueue(int *a,int front,int rear){
    //如果front==rear，表示队列为空
    if(front==rear%max) {
        printf("队列为空");
        return front;
    }
    printf("%d ",a[front]);
    //front不再直接 +1，而是+1后同max进行比较，如果=max，则直接跳转到 a[0]
    front=(front+1)%max;
    return front;
}
int main() {
    int a[max];
    int front,rear;
    //设置队头指针和队尾指针，当队列中没有元素时，队头和队尾指向同一块地址
    front=rear=0;
    //入队
    rear=enQueue(a,front,rear, 1);
    rear=enQueue(a,front,rear, 2);
    rear=enQueue(a,front,rear, 3);
    rear=enQueue(a,front,rear, 4);
    //出队
    front=deQueue(a, front, rear);
    //再入队
    rear=enQueue(a,front,rear, 5);
    //再出队
    front=deQueue(a, front, rear);
    //再入队
    rear=enQueue(a,front,rear, 6);
    //再出队
    front=deQueue(a, front, rear);
    front=deQueue(a, front, rear);
    front=deQueue(a, front, rear);
    front=deQueue(a, front, rear);
    return 0;
}
```

程序运行结果：

```shell
1 2 3 4 5 6
```

使用此方法需要注意的是，顺序队列在判断数组是否已满时，出现下面情况：

- 当队列为空时，队列的头指针等于队列的尾指针；
- 当数组满员时，队列的头指针等于队列的尾指针；


顺序队列的存储状态不同，但是判断条件相同。为了对其进行区分，最简单的解决办法是：牺牲掉数组中的一个存储空间，判断数组满员的条件是：尾指针的下一个位置和头指针相遇，就说明数组满了，即程序中第 5 行所示。

##### 3.6 链式队列 

>http://data.biancheng.net/view/174.html



#### 四 字符串和多维数组

##### 4.1 什么是串存储结构 

数据结构中，字符串要单独用一种存储结构来存储，称为串存储结构。这里的串指的就是字符串。

严格意义上讲，串存储结构也是一种线性存储结构，因为字符串中的字符之间也具有"一对一"的逻辑关系。只不过，与之前所学的线性存储结构不同，串结构只用于存储字符类型的数据。

无论学习哪种编程语言，操作最多的总是字符串。数据结构中，根据串中存储字符的数量及特点，对一些特殊的串进行了命名，比如说：

- 空串：存储 0 个字符的串，例如 S = ""（双引号紧挨着）；
- 空格串：只包含空格字符的串，例如 S = "   "（双引号包含 5 个空格）；
- 子串和主串：假设有两个串 a 和 b，如果 a 中可以找到几个连续字符组成的串与 b 完全相同，则称 a 是 b 的主串，b 是 a 的子串。例如，若 a = "shujujiegou"，b = "shuju"，由于 a 中也包含 "shuju"，因此串 a 和串 b 是主串和子串的关系；


需要注意的是，空格串和空串不同，空格串中含有字符，只是都是空格而已。另外，只有串 b 整体出现在串 a 中，才能说 b 是 a 的子串，比如 "shujiejugou" 和 "shuju" 就不是主串和子串的关系。

另外，对于具有主串和子串关系的两个串，通常会让你用算法找到子串在主串的位置。子串在主串中的位置，指的是子串首个字符在主串中的位置。

例如，串 a = "shujujiegou"，串 b = "jiegou"，通过观察，可以判断 a 和 b 是主串和子串的关系，同时子串 b 位于主串 a 中第 6 的位置，因为在串 a 中，串 b 首字符 'j' 的位置是 6。

本章，我们会学习两种模式匹配算法专门解决此类问题。

###### 4.1.1 串存储结构的具体实现

存储一个字符串，数据结构包含以下 3 种具体存储结构：

1. 定长顺序存储：实际上就是用普通数组（又称静态数组）存储。例如 C 语言使用普通数据存储字符串的代码为 char a[20] = "data.biancheng.net"；
2. 堆分配存储：用动态数组存储字符串；
3. 块链存储：用链表存储字符串；

以上 3 种存储结构会在后续文章中作详细介绍。

##### 4.2 串的存储

> http://data.biancheng.net/view/177.html 



##### 4.3 串的算法 

>bmp 算法 
>
>kmp 算法  http://data.biancheng.net/view/180.html



##### 4.4 什么是数组

前面学习数据结构的过程中，总是使用数组作为顺序表的底层实现，给我们一种 "数据结构中，数组的作用就是实现顺序表" 的错误认识。其实，数组的作用远不止于此。

本节将从数据结构的角度讲解数组存储结构。

本节所讲的数组，要将其视为一种存储结构，与平时使用的数组基本数据类型区分开。

一说起数组，我们的印象中数组往往是某一门编程语言中包含的具体数据类型，其实不然。

从本质上讲，数组与顺序表、链表、栈和队列一样，都用来存储具有 "一对一" 逻辑关系数据的线性存储结构。只因各编程语言都默认将数组作为基本数据类型，使初学者对数组有了 "只是基本数据类型，不是存储结构" 的误解。

不仅如此，数组和其他线性存储结构不同，顺序表、链表、栈和队列存储的都是不可再分的数据元素（如数字 5、字符 'a' 等），而数组既可以用来存储不可再分的数据元素，也可以用来存储像顺序表、链表这样的数据结构。

比如说，数组可以直接存储多个顺序表。我们知道，顺序表的底层实现还是数组，因此等价于数组中继续存储数组。这与平时使用的二维数组类似。

根据数组中存储数据之间逻辑结构的不同，数组可细分为一维数组、二维数组、...、n 维数组：

- 一维数组，指的是存储不可再分数据元素的数组，如图1 所示；


  ![一维数组存储结构示意图](http://data.biancheng.net/uploads/allimg/181214/2-1Q21419542I92.gif)

  <center>图 1 一维数组存储结构示意图</center>

- 二维数组，指的存储一维数组的一维数组，如图 2 所示；


  ![二维数组存储结构示意图](http://data.biancheng.net/uploads/allimg/181214/2-1Q214195P0Z9.gif)

  <center>图 2 二维数组存储结构示意图</center>

- n 维数组，指的是存储 n-1 维数组的一维数组；

注意，无论数组的维数是多少，数组中的数据类型都必须一致。

由此，我们可以得出这样一个结论，一维数组结构是线性表

的基本表现形式，而 n 维数组可理解为是对线性存储结构的一种扩展。

##### 4.5 数组的顺序存储及实现



#### 五 树和二叉树



#### 六 图



#### 七 查找技术 



#### 八 排序技术 

##### 8.1 插入排序  

插入排序算法是所有排序方法中最简单的一种算法，其主要的实现思想是将数据按照一定的顺序一个一个的插入到有序的表中，最终得到的序列就是已经排序好的数据。

###### 8.1.1 直接插入排序

直接插入排序是插入排序算法中的一种，采用的方法是：在添加新的记录时，使用[顺序查找](http://data.biancheng.net/view/54.html)的方式找到其要插入的位置，然后将新记录插入。

> 很多初学者所说的插入排序，实际上指的就是直接插入排序算法，插入排序算法还包括折半插入排序、2-路插入排序，表插入排序和希尔排序等，后序文章都会一一讲到。

例如采用直接插入排序算法将无序表`{3,1,7,5,2,4,9,6}`进行升序排序的过程为：

- 首先考虑记录 3 ，由于插入排序刚开始，有序表中没有任何记录，所以 3 可以直接添加到有序表中，则有序表和无序表可以如图 1 所示：

![img](http://data.biancheng.net/uploads/allimg/171031/2-1G031100936450.png)

<center>图 1 直接插入排序（1)</center>

- 向有序表中插入记录 1 时，同有序表中记录 3 进行比较，1<3，所以插入到记录 3 的左侧，如图 2 所示：


![img](http://data.biancheng.net/uploads/allimg/171031/2-1G0311010064T.png)

<center>图 2 直接插入排序（2)</center>

- 向有序表插入记录 7 时，同有序表中记录 3 进行比较，3<7，所以插入到记录 3 的右侧，如图 3 所示：


![img](http://data.biancheng.net/uploads/allimg/171031/2-1G031101030I8.png)

<center>图 3 直接插入排序（3)</center>

- 向有序表中插入记录 5 时，同有序表中记录 7 进行比较，5<7，同时 5>3，所以插入到 3 和 7 中间，如图 4 所示：


![img](http://data.biancheng.net/uploads/allimg/171031/2-1G03110110b64.png)

<center>图 4 直接插入排序（4)</center>

- 向有序表插入记录 2 时，同有序表中记录 7进行比较，2<7，再同 5，3，1分别进行比较，最终确定 2 位于 1 和 3 中间，如图 5 所示：

![img](http://data.biancheng.net/uploads/allimg/171031/2-1G03110112H34.png)

<center>图 5 直接插入排序（5)</center> 

- 照此规律，依次将无序表中的记录 4，9 和 6插入到有序表中，如图 6 所示：


![img](http://data.biancheng.net/uploads/allimg/171031/2-1G031101156448.png)

<center>图 6 依次插入记录4，9和6</center> 



###### 8.1.2 折半插入排序

​	利用折半查找来代替顺序查找

###### 8.1.3  2路插入排序



###### 8.1.4 希尔排序 

>http://data.biancheng.net/view/69.html

希尔排序，又称“缩小增量排序”，也是插入排序的一种，但是同前面几种排序算法比较来看，希尔排序在时间效率上有很大的改进。

在使用直接

[插入排序算法](http://data.biancheng.net/view/65.html)

时，如果表中的记录只有个别的是无序的，多数保持有序，这种情况下算法的效率也会比较高；除此之外，如果需要排序的记录总量很少，该算法的效率同样会很高。希尔排序就是从这两点出发对算法进行改进得到的排序算法。

> 希尔排序的具体实现思路是：先将整个记录表分割成若干部分，分别进行直接插入排序，然后再对整个记录表进行一次直接插入排序。

例如无序表`{49，38，65，97，76，13，27，49，55，4}`进行希尔排序的过程为：

- 首先对 {49，13}，{38，27}，{65，49}，{97，55}，{76，4} 分别进行直接插入排序（如果需要调换位置也只是互换存储位置），如下图所示：



![img](http://data.biancheng.net/uploads/allimg/171031/2-1G031111300510.png)

上图中两两进行比较，例如 49 和 13 进行比较，13<49，所以交换存储位置。


- 通过一次排序，无序表中的记录已基本有序，此时还可以再进行一次分割，如下图所示：


![img](http://data.biancheng.net/uploads/allimg/171031/2-1G031111325V0.png)



- 经过两次分割，无序表中已基本有序，此时对整张表进行一次直接插入排序（只需要做少量的比较和插入操作即可），最终希尔排序的结果为：

  ​	


  ![img](http://data.biancheng.net/uploads/allimg/171031/2-1G031111351218.png)

   

希尔排序的过程中，对于分割的每个子表，其各自包含的记录在原表中并不是相互挨着的，而是相互之间相隔着某个固定的常数。例如上例中第一次排序时子表中的记录分割的常量为 5，第二次排序时为 3。

通过此种方式，对于关键字的值较小的记录，其前移的过程不是一步一步的，而是跳跃性的前移，并且在最后一次对整表进行插入排序时减少了比较和排序的次数。

> 一般在记录的数量多的情况下，希尔排序的排序效率较直接插入排序高。

希尔排序的具体代码实现：



##### 8.2 交换排序

###### 8.2.1 冒泡排序 

起泡排序，别名“冒泡排序”，该算法的核心思想是将无序表中的所有记录，通过两两比较关键字，得出升序序列或者降序序列。

例如，对无序表`{49，38，65，97，76，13，27，49}`进行升序排序的具体实现过程如图 1 所示：



![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G0305Jb.png)

图 1 第一次起泡


如图 1 所示是对无序表的第一次起泡排序，最终将无序表中的最大值 97 找到并存储在表的最后一个位置。具体实现过程为：

1. 首先 49 和 38 比较，由于 38<49，所以两者交换位置，即从（1）到（2）的转变；
2. 然后继续下标为 1 的同下标为 2 的进行比较，由于 49<65，所以不移动位置，（3）中 65 同 97 比较得知，两者也不需要移动位置；
3. 直至（4），97 同 76 进行比较，76<97，两者交换位置，如（5）所示；
4. 同样 97>13（5）、97>27（6）、97>49（7），所以经过一次冒泡排序，最终在无序表中找到一个最大值 97，第一次冒泡结束；


由于 97 已经判断为最大值，所以第二次冒泡排序时就需要找出除 97 之外的无序表中的最大值，比较过程和第一次完全相同。



![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G0321L94.png)


经过第二次冒泡，最终找到了除 97 之外的又一个最大值 76，比较过程完全一样，这里不再描述。

> 通过一趟趟的比较，一个个的“最大值”被找到并移动到相应位置，直到检测到表中数据已经有序，或者比较次数等同于表中含有记录的个数，排序结束，这就是起泡排序。

**总结** 

使用起泡排序算法，其[时间复杂度](http://data.biancheng.net/view/2.html)同实际表中数据的无序程度有关。若表中记录本身为正序存放，则整个排序过程只需进行 n-1（n 为表中记录的个数）次比较，且不需要移动记录；若表中记录为逆序存放（最坏的情况），则需要 n-1趟排序，进行 n(n-1)/2 次比较和数据的移动。所以该算法的时间复杂度为`O(n2)`。



###### 8.2.2 快速排序

> http://data.biancheng.net/view/71.html
>
> C语言中自带函数库中就有快速排序——qsort函数 ，包含在 <stdlib.h> 头文件中。

快速排序算法是在起泡排序的基础上进行改进的一种算法，其实现的基本思想是：通过一次排序将整个无序表分成相互独立的两部分，其中一部分中的数据都比另一部分中包含的数据的值小，然后继续沿用此方法分别对两部分进行同样的操作，直到每一个小部分不可再分，所得到的整个序列就成为了有序序列。

例如，对无序表`{49，38，65，97，76，13，27，49}`进行快速排序，大致过程为：

1. 首先从表中选取一个记录的关键字作为分割点（称为“枢轴”或者支点，一般选择第一个关键字），例如选取 49；
2. 将表格中大于 49 个放置于 49 的右侧，小于 49 的放置于 49 的左侧，假设完成后的无序表为：`{27，38，13，49，65，97，76，49}`；
3. 以 49 为支点，将整个无序表分割成了两个部分，分别为`{27，38，13}`和`{65，97，76，49}`，继续采用此种方法分别对两个子表进行排序；
4. 前部分子表以 27 为支点，排序后的子表为`{13，27，38}`，此部分已经有序；后部分子表以 65 为支点，排序后的子表为`{49，65，97，76}`；
5. 此时前半部分子表中的数据已完成排序；后部分子表继续以 65为支点，将其分割为`{49}`和`{97，76}`，前者不需排序，后者排序后的结果为`{76，97}`；
6. 通过以上几步的排序，最后由子表`{13，27，38}`、`{49}`、`{49}`、`{65}`、`{76，97}`构成有序表：`{13，27，38，49，49，65，76，97}`；


整个过程中最重要的是实现第 2 步的分割操作，具体实现过程为：



- 设置两个指针 low 和 high，分别指向无序表的表头和表尾，如下图所示：

![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G04923K2.png)

- 先由 high 指针从右往左依次遍历，直到找到一个比 49 小的关键字，所以 high 指针走到 27 的地方停止。找到之后将该关键字同 low 指向的关键字进行互换：

![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G049532B.png)

- 然后指针 low 从左往右依次遍历，直到找到一个比 49 大的关键字为止，所以 low 指针走到 65 的地方停止。同样找到后同 high 指向的关键字进行互换：

![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G05009508.png)

- 指针 high 继续左移，到 13 所在的位置停止（13<49），然后同 low 指向的关键字进行互换：

![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G05034131.png)

- 指针 low 继续右移，到 97 所在的位置停止（97>49），然后同 high 指向的关键字互换位置：

![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G05050L2.png)

- 指针 high 继续左移，此时两指针相遇，整个过程结束；



##### 8.3 选择排序 

###### 8.3.1 简单选择排序

该算法的实现思想为：对于具有 n 个记录的无序表遍历 n-1 次，第 i 次从无序表中第 i 个记录开始，找出后序关键字中最小的记录，然后放置在第 i 的位置上。

例如对无序表`{56，12，80，91，20}`采用简单选择排序算法进行排序，具体过程为：

- 第一次遍历时，从下标为 1 的位置即 56 开始，找出关键字值最小的记录 12，同下标为 0 的关键字 56 交换位置：

![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G11033T5.png)

- 第二次遍历时，从下标为 2 的位置即 56 开始，找出最小值 20，同下标为 2 的关键字 56 互换位置：

![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G1105KP.png)

- 第三次遍历时，从下标为 3 的位置即 80 开始，找出最小值 56，同下标为 3 的关键字 80 互换位置：

![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G11112303.png)

- 第四次遍历时，从下标为 4 的位置即 91 开始，找出最小是 80，同下标为 4 的关键字 91 互换位置：

![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G1112A61.png)

- 到此简单选择排序算法完成，无序表变为有序表。

###### 8.3.2  堆排序

在学习堆排序之前，首先需要了解堆的含义：在含有 n 个元素的序列中，如果序列中的元素满足下面其中一种关系时，此序列可以称之为堆。



- ki ≤ k2i 且 ki ≤ k2i+1（在 n 个记录的范围内，第 i 个关键字的值小于第 2*i 个关键字，同时也小于第 2*i+1 个关键字）
- ki ≥ k2i 且 ki ≥ k2i+1（在 n 个记录的范围内，第 i 个关键字的值大于第 2*i 个关键字，同时也大于第 2*i+1 个关键字）


对于堆的定义也可以使用完全二叉树来解释，因为在完全二叉树中第 i 个结点的左孩子恰好是第 2i 个结点，右孩子恰好是 2i+1 个结点。如果该序列可以被称为堆，则使用该序列构建的完全二叉树中，每个根结点的值都必须不小于（或者不大于）左右孩子结点的值。

以无序表`{49，38，65，97，76，13，27，49}`来讲，其对应的堆用完全二叉树来表示为：

![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G11P3256.png)
图 3 无序表对应的堆

> 提示：堆用完全二叉树表示时，其表示方法不唯一，但是可以确定的是树的根结点要么是无序表中的最小值，要么是最大值。

通过将无序表转化为堆，可以直接找到表中最大值或者最小值，然后将其提取出来，令剩余的记录再重建一个堆，取出次大值或者次小值，如此反复执行就可以得到一个有序序列，此过程为堆排序。

堆排序过程的代码实现需要解决两个问题：

1. 如何将得到的无序序列转化为一个堆？
2. 在输出堆顶元素之后（完全二叉树的树根结点），如何调整剩余元素构建一个新的堆？

首先先解决第 2 个问题。图 3 所示为一个完全二叉树，若去除堆顶元素，即删除二叉树的树根结点，此时用二叉树中最后一个结点 97 代替，如下图所示：

![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G1192WU.png)

此时由于结点 97 比左右孩子结点的值都大，破坏了堆的结构，所以需要进行调整：首先以 堆顶元素 97 同左右子树比较，同值最小的结点交换位置，即 27 和 97 交换位置：


![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G1194A41.png)

 

由于替代之后破坏了根结点右子树的堆结构，所以需要进行和上述一样的调整，即令 97 同 49 进行交换位置：


![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G12003264.png)

 

通过上述的调整，之前被破坏的堆结构又重新建立。从根结点到叶子结点的整个调整的过程，被称为“筛选”。

解决第一个问题使用的就是不断筛选的过程，如下图所示，无序表`{49，38，65，97，76，13，27，49}`初步建立的完全二叉树，如下图所示：


![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G12041N3.png)

 

在对上图做筛选工作时，规律是从底层结点开始，一直筛选到根结点。对于具有 n 个结点的完全二叉树，筛选工作开始的结点为第 ⌊n/2⌋个结点（此结点后序都是叶子结点，无需筛选）。

所以，对于有 9 个结点的完全二叉树，筛选工作从第 4 个结点 97 开始，由于 97 > 49 ,所以需要相互交换，交换后如下图所示：


![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G1212b35.png)

 

然后再筛选第 3 个结点 65 ，由于 65 比左右孩子结点都大，则选择一个最小的同 65 进行交换，交换后的结果为：


![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G1214J09.png)

 

然后筛选第 2 个结点，由于其符合要求，所以不用筛选；最后筛选根结点 49 ，同 13 进行交换，交换后的结果为：


![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G12204617.png)

 

交换后，发现破坏了其右子树堆的结构，所以还需要调整，最终调整后的结果为：


![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G12221A8.png)





##### 8.4 归并排序

>http://data.biancheng.net/view/73.html

本节介绍一种不同于插入排序和[选择排序](http://data.biancheng.net/view/72.html)的排序方法——归并排序，其排序的实现思想是先将所有的记录完全分开，然后两两合并，在合并的过程中将其排好序，最终能够得到一个完整的有序表。

例如对于含有 n 个记录的无序表，首先默认表中每个记录各为一个有序表（只不过表的长度都为 1），然后进行两两合并，使 n 个有序表变为 ⌈n/2⌉ 个长度为 2 或者 1 的有序表（例如 4 个小有序表合并为 2 个大的有序表），通过不断地进行两两合并，直到得到一个长度为 n 的有序表为止。这种归并排序方法称为：2-路归并排序。

例如对无序表`{49，38，65，97，76，13，27}`进行 2-路归并排序的过程如图 1 所示：



![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G51010T8.png)

<center>图 1 归并排序过程</center>

> 归并过程中，每次得到的新的子表本身有序，所以最终得到的为有序表。

**总结**

提示：归并排序算法在具体实现时，首先需要将整个记录表进行折半分解，直到分解为一个记录作为单独的一张表为止，然后在进行两两合并。整个过程为分而后立的过程。

归并排序算法的[时间复杂度](http://data.biancheng.net/view/2.html)为`O(nlogn)`。该算法相比于堆排序和快速排序，其主要的优点是：当记录表中含有值相同的记录时，排序前和排序后在表中的相对位置不会改变。

例如，在记录表中记录 a 在记录 b 的前面（记录 a 和 b 的关键字的值相等），使用归并排序之后记录 a 还在记录 b 的前面。这就体现出了该排序算法的稳定性。而堆排序和快速排序都是不稳定的。

##### 8.5 分配排序 

###### 8.5.1 基数排序 

>http://data.biancheng.net/view/74.html

基数排序不同于之前所介绍的各类排序，前边介绍到的排序方法或多或少的是通过使用比较和移动记录来实现排序，而基数排序的实现不需要进行对关键字的比较，只需要对关键字进行“分配”与“收集”两种操作即可完成。

例如对无序表`{50，123，543，187，49，30，0，2，11，100}`进行基数排序，由于每个关键字都是整数数值，且其中的最大值由个位、十位和百位构成，每个数位上的数字从 0 到 9，首先将各个关键字按照其个位数字的不同进行分配分配表如下图所示：


![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G51924160.png)

 

通过按照各关键字的个位数进行分配，按照顺序收集得到的序列变为：`{50，30，0，100，11，2，123，543，187，49}`。在该序列表的基础上，再按照各关键字的十位对各关键字进行分配，得到的分配表如下图所示：


![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G5203O92.png)

 

由上表顺序收集得到的记录表为：`{0、100、2、11、123、30、543、49、50、187}`。在该无序表的基础上，依次将表中的记录按照其关键字的百位进行分配，得到的分配如下图所示：


![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G521323L.png)

 

最终通过三次分配与收集，最终得到的就是一个排好序的有序表：`{0、2、11、30、49、50、100、123、187、543}`。

例子中是按照个位-十位-百位的顺序进行基数排序，此种方式是从最低位开始排序，所以被称为最低位优先法（简称“LSD法”）。

同样还可以按照百位-十位-各位的顺序进行排序，称为最高位优先法（简称“MSD法”），使用该方式进行排序同最低位优先法不同的是：当无序表中的关键字进行分配后，相当于进入了多个子序列，后序的排序工作分别在各个子序列中进行（最低位优先法每次分配与收集都是相对于整个序列表而言的）。

例如还是对`{50，123，543，187，49，30，0，2，11，100}`使用最高位优先法进行排序，首先按照百位的不同进行分配，得到的分配表为：


![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G52325938.png)

 

由上图所示，整个无序表被分为了 3 个子序列，序列 1 和序列 2 中含有多个关键字，序列 3 中只包含了一个关键字，最高位优先法完成排序的标准为：直到每个子序列中只有一个关键字为止，所以需要分别对两个子序列进行再分配，各自的分配表如下图所示：


![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G52354334.png)

 

上表中，序列 1 中还有含有两个关键字的子序列，所以还需要根据个位进行分配，最终按照各子序列的顺序同样会得到一个有序表。

###### 8.5.2 桶排序 

>不确定是否要学习



##### 8.6 内部排序算法优势分析(比较)

本章介绍了以下几种常见的排序算法：

- 插入排序：直接插入排序、折半插入排序、2-路插入排序、表插入排序和希尔排序；
- 起泡排序（[冒泡排序](http://data.biancheng.net/view/70.html)）；
- 快速排序（快排）；
- [选择排序](http://data.biancheng.net/view/72.html)：简单选择排序、[树](http://data.biancheng.net/view/23.html)形选择排序和堆排序；
- 归并排序；
- 基数排序；

###### 8.6.1 时间性能上的分析

![img](http://data.biancheng.net/uploads/allimg/171107/2-1G10G54150258.png)

> 上表中的简单排序包含出希尔排序之外的所有插入排序，起泡排序和简单选择排序。同时表格中的 n 表示无序表中记录的数量；基数排序中的 d 表示进行分配和收集的次数。

在上表表示的所有“简单排序算法”中，以直接[插入排序算法](http://data.biancheng.net/view/65.html)最为简单，当无序表中的记录数量 n 较小时，选择该算法为最佳排序方法。

所有的排序算法中单就平均时间性能上分析，快速排序算法最佳，其运行所需的时间最短，但其在最坏的情况下的时间性能不如堆排序和归并排序；堆排序和归并排序相比较，当无序表中记录的数量 n 较大时，归并排序所需时间比堆排序短，但是在运行过程中所需的辅助存储空间更多（以空间换时间）。

从基数排序的

[时间复杂度](http://data.biancheng.net/view/2.html)

上分析，该算法最适用于对 n 值很大但是关键字较小的序列进行排序。

在所有基于“比较”实现的排序算法中（以上排序算法中除了基数排序，都是基于“比较”实现），其在最坏情况下能达到的最好的时间复杂度为`O(nlogn)`。

###### 8.6.2 算法稳定性

本章所介绍的所有排序算法中，选择排序、快速排序和希尔排序都不是稳定的排序算法；而冒泡排序、插入排序、归并排序和基数排序都是稳定的排序算法。

###### 8.6.3 算法实现的存储结构

本章所介绍的大多数算法都是在顺序存储结构的基础上实现的，基于顺序存储结构的局限性，排序算法在排序过程都需要进行大量记录的移动，影响算法本身的效率。

当无序表中记录的数量很大时，就需要采用

[静态链表](http://data.biancheng.net/view/163.html)

替换顺序存储结构，例如：表插入排序、链式基数排序算法，是以修改指针代替大量移动记录的方式提高算法效率。

###### 8.6.4 本章小结

通过比较所有的排序算法，没有哪一种是绝对最优的，在使用时需要根据不同的实际情况适当选择合适的排序算法，甚至可以考虑将多种排序算法结合起来使用。